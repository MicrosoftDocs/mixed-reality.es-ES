---
title: Análisis de rendimiento de la realidad mixta
description: Advanced temas y los detalles sobre cómo optimizar el rendimiento de aplicaciones de realidad mixta de Windows
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows mixto en realidad, la realidad mixta, en realidad Virtual, VR, MR, rendimiento, optimización, CPU, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/12/2019
ms.locfileid: "59605375"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="47258-104">Análisis de rendimiento de la realidad mixta</span><span class="sxs-lookup"><span data-stu-id="47258-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="47258-105">En este artículo es una introducción a racionalizar la importancia del rendimiento de la aplicación de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="47258-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="47258-106">Experiencia del usuario puede disminuir considerablemente si la aplicación no se ejecuta en la velocidad de fotogramas óptima.</span><span class="sxs-lookup"><span data-stu-id="47258-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="47258-107">Hologramas aparecerán inestables y seguimiento principal del entorno puede ser impreciso, dando lugar a una mala experiencia para el usuario.</span><span class="sxs-lookup"><span data-stu-id="47258-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="47258-108">De hecho, el rendimiento debe considerarse como una característica de primera clase para el desarrollo de realidad mixta y no una estabilización, al final de la tarea de ciclo.</span><span class="sxs-lookup"><span data-stu-id="47258-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="47258-109">Para su revisión, continuación se enumeran los valores de velocidad de fotogramas de alto rendimiento para cada plataforma de destino.</span><span class="sxs-lookup"><span data-stu-id="47258-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="47258-110">Plataforma</span><span class="sxs-lookup"><span data-stu-id="47258-110">Platform</span></span> | <span data-ttu-id="47258-111">Velocidad de fotogramas de destino</span><span class="sxs-lookup"><span data-stu-id="47258-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="47258-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="47258-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="47258-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="47258-113">60 FPS</span></span> |
| [<span data-ttu-id="47258-114">Windows Mixed Reality Ultra PCs</span><span class="sxs-lookup"><span data-stu-id="47258-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="47258-115">FPS 90</span><span class="sxs-lookup"><span data-stu-id="47258-115">90 FPS</span></span> |
| [<span data-ttu-id="47258-116">Windows mixto realidad PCs</span><span class="sxs-lookup"><span data-stu-id="47258-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="47258-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="47258-117">60 FPS</span></span> |

<span data-ttu-id="47258-118">El marco de trabajo siguiente proporciona una descripción general de los procedimientos recomendados y concepciones hacia alcanzar velocidades de fotogramas de destino.</span><span class="sxs-lookup"><span data-stu-id="47258-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="47258-119">Para profundizar aún más en obtener más información, puede leer el [recomendaciones de rendimiento para el artículo de Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="47258-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="47258-120">En concreto, este artículo relacionado describe cómo medir la velocidad de fotogramas en la aplicación de Unity Windows Mixed Reality, así como los pasos en el entorno de Unity para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="47258-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="47258-121">Descripción de los cuellos de botella de rendimiento</span><span class="sxs-lookup"><span data-stu-id="47258-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="47258-122">Si la aplicación tiene una velocidad de fotogramas déficit de rendimiento, el primer paso es analizar y comprender donde la aplicación es computacionalmente intensiva.</span><span class="sxs-lookup"><span data-stu-id="47258-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="47258-123">Hay dos procesadores principales responsable de trabajo para representar la escena: la CPU y la GPU.</span><span class="sxs-lookup"><span data-stu-id="47258-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="47258-124">Cada uno de estos dos componentes controlar operaciones diferentes y las fases de la aplicación de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="47258-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="47258-125">Hay tres lugares claves donde se produzcan cuellos de botella.</span><span class="sxs-lookup"><span data-stu-id="47258-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="47258-126">**Subproceso de la aplicación - CPU** -este subproceso es responsable de la lógica de aplicación.</span><span class="sxs-lookup"><span data-stu-id="47258-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="47258-127">Esto incluye el procesamiento de entrada, animaciones, física y otra lógica y estado de la aplicación</span><span class="sxs-lookup"><span data-stu-id="47258-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="47258-128">**Representar subproceso - CPU al GPU** -este subproceso es responsable de enviar las llamadas de dibujo a la GPU.</span><span class="sxs-lookup"><span data-stu-id="47258-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="47258-129">Cuando la aplicación quiere presentar un objeto como un cubo o modelo, este subproceso envía una solicitud a la GPU, que tiene una arquitectura optimizada para la representación, para realizar estas operaciones.</span><span class="sxs-lookup"><span data-stu-id="47258-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="47258-130">**GPU** - 
    este procesador normalmente controla la canalización de gráficos de la aplicación para transformar datos 3D (modelos, las texturas, etcetera) en píxeles y, finalmente, producen una imagen 2D para enviar a la pantalla del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="47258-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Duración de un marco](images/lifetime-of-a-frame.png)

<span data-ttu-id="47258-132">Por lo general, las aplicaciones de HoloLens estarán limitado de GPU.</span><span class="sxs-lookup"><span data-stu-id="47258-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="47258-133">Sin embargo, esto no es cierta en todas las aplicaciones y, por tanto, se recomienda usar las herramientas y técnicas a continuación para ir a la verdad terreno para su aplicación en particular.</span><span class="sxs-lookup"><span data-stu-id="47258-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="47258-134">Cómo analizar la aplicación</span><span class="sxs-lookup"><span data-stu-id="47258-134">How to analyze your application</span></span>

<span data-ttu-id="47258-135">Hay muchas herramientas que permiten los desarrolladores comprender el perfil de rendimiento de la aplicación de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="47258-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="47258-136">Estos le permitirá a ambas destino donde haya cuellos de botella y cómo se se manifiesta a sí mismos para depurarlos.</span><span class="sxs-lookup"><span data-stu-id="47258-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="47258-137">Se trata de una lista de las herramientas más populares y eficaces para obtener información sobre los perfiles profundo para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="47258-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="47258-138">Analizadores de rendimiento de gráficos de Intel</span><span class="sxs-lookup"><span data-stu-id="47258-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="47258-139">Depuradores de gráficos de Visual Studio</span><span class="sxs-lookup"><span data-stu-id="47258-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="47258-140">Profiler de Unity</span><span class="sxs-lookup"><span data-stu-id="47258-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="47258-141">Depurador de marco de Unity</span><span class="sxs-lookup"><span data-stu-id="47258-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="47258-142">Cómo generar perfiles en cualquier entorno</span><span class="sxs-lookup"><span data-stu-id="47258-142">How to profile in any environment</span></span>

<span data-ttu-id="47258-143">Hay una prueba sencilla para determinar rápidamente que si es probable que delimitado GPU o CPU limitada en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="47258-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="47258-144">Si reduce la resolución de la salida del destino de representación, hay menos píxeles para calcular y por lo tanto, menos trabajo la GPU debe llevar a cabo para representar una imagen.</span><span class="sxs-lookup"><span data-stu-id="47258-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="47258-145">Ventanilla escalado (escalado de resolución dinámica) es la práctica de representar la imagen a un menor destino de representación, a continuación, puede mostrar el dispositivo de salida.</span><span class="sxs-lookup"><span data-stu-id="47258-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="47258-146">El dispositivo se muestra a arriba desde el conjunto más pequeño de píxeles para mostrar la imagen final.</span><span class="sxs-lookup"><span data-stu-id="47258-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="47258-147">Después de disminuir la resolución de representación, si:</span><span class="sxs-lookup"><span data-stu-id="47258-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="47258-148">Velocidad de fotogramas de aplicación **aumenta**, es probable **limitado de GPU**</span><span class="sxs-lookup"><span data-stu-id="47258-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="47258-149">Velocidad de fotogramas de aplicación **sin cambios**, es probable **CPU limitada**</span><span class="sxs-lookup"><span data-stu-id="47258-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="47258-150">Unity ofrece la posibilidad de modificar fácilmente la resolución de destino de representación de la aplicación en tiempo de ejecución a través de la *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* propiedad.</span><span class="sxs-lookup"><span data-stu-id="47258-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="47258-151">La imagen final que se presentan en el dispositivo tiene una resolución fija.</span><span class="sxs-lookup"><span data-stu-id="47258-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="47258-152">La plataforma realizará una muestra la resolución más baja para crear una imagen de resolución superior para la representación en pantallas de salida.</span><span class="sxs-lookup"><span data-stu-id="47258-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="47258-153">Cómo mejorar la aplicación</span><span class="sxs-lookup"><span data-stu-id="47258-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="47258-154">Recomendaciones de rendimiento de CPU</span><span class="sxs-lookup"><span data-stu-id="47258-154">CPU performance recommendations</span></span>

<span data-ttu-id="47258-155">Por lo general, la mayoría del trabajo en una aplicación de realidad mixta en la CPU implica realizar la simulación de"" de la escena y lógica de aplicación único de forma exhaustiva de procesamiento.</span><span class="sxs-lookup"><span data-stu-id="47258-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="47258-156">Por lo tanto, las áreas siguientes normalmente están destinadas para la optimización.</span><span class="sxs-lookup"><span data-stu-id="47258-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="47258-157">Animaciones</span><span class="sxs-lookup"><span data-stu-id="47258-157">Animations</span></span>
- <span data-ttu-id="47258-158">Simplificar la física</span><span class="sxs-lookup"><span data-stu-id="47258-158">Simplify Physics</span></span>
- <span data-ttu-id="47258-159">Asignaciones de memoria</span><span class="sxs-lookup"><span data-stu-id="47258-159">Memory allocations</span></span>
- <span data-ttu-id="47258-160">Algoritmos complejos (como)</span><span class="sxs-lookup"><span data-stu-id="47258-160">Complex algorithms (i.e</span></span> <span data-ttu-id="47258-161">cinemática inversa, búsqueda de ruta de acceso)</span><span class="sxs-lookup"><span data-stu-id="47258-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="47258-162">Recomendaciones de rendimiento de GPU</span><span class="sxs-lookup"><span data-stu-id="47258-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="47258-163">Tasa de relleno de vs de ancho de banda de descripción</span><span class="sxs-lookup"><span data-stu-id="47258-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="47258-164">Al representar un fotograma en la GPU, una aplicación es generalmente limitado por la tasa de relleno o el ancho de banda de memoria.</span><span class="sxs-lookup"><span data-stu-id="47258-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="47258-165">**Ancho de banda de memoria** es la velocidad de lecturas y escrituras puede realizar la GPU de la memoria</span><span class="sxs-lookup"><span data-stu-id="47258-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="47258-166">Para identificar las limitaciones de ancho de banda, reducir la calidad de textura y compruebe si ha mejorado la velocidad de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="47258-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="47258-167">En Unity, esto puede hacerse cambiando **Texture Quality** en **editar** > **configuración del proyecto**  >   **[ Configuración de calidad](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span><span class="sxs-lookup"><span data-stu-id="47258-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="47258-168">**Velocidad de relleno** se refiere al rendimiento de los píxeles representados que se pueden dibujar por segundo por la GPU.</span><span class="sxs-lookup"><span data-stu-id="47258-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="47258-169">Para identificar las limitaciones de velocidad de relleno, disminuir la resolución de pantalla y compruebe si ha mejorado la velocidad de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="47258-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="47258-170">En Unity, esto puede hacerse a través de la *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* propiedad</span><span class="sxs-lookup"><span data-stu-id="47258-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="47258-171">Ancho de banda de memoria, normalmente hay optimizaciones para cualquiera</span><span class="sxs-lookup"><span data-stu-id="47258-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="47258-172">disminuir las resoluciones de textura</span><span class="sxs-lookup"><span data-stu-id="47258-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="47258-173">utilizar menos texturas (como)</span><span class="sxs-lookup"><span data-stu-id="47258-173">utilize less textures (i.e</span></span> <span data-ttu-id="47258-174">etcetera de reflexión especular, Normals)</span><span class="sxs-lookup"><span data-stu-id="47258-174">normals, specular, etc)</span></span>

<span data-ttu-id="47258-175">Tasa de relleno se centra principalmente en lo que reduce el número de operaciones que deben calcularse para un píxel final representado.</span><span class="sxs-lookup"><span data-stu-id="47258-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="47258-176">Ejemplos de esto normalmente se dividen en reducir</span><span class="sxs-lookup"><span data-stu-id="47258-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="47258-177">número de objetos para representar y procesar</span><span class="sxs-lookup"><span data-stu-id="47258-177">number of objects to render/process</span></span>
2) <span data-ttu-id="47258-178">número de operaciones por sombreador</span><span class="sxs-lookup"><span data-stu-id="47258-178">number of operations per shader</span></span>
3) <span data-ttu-id="47258-179">número de fases GPU para el resultado final (sombreadores de geometría, posteriores al procesamiento efectos, etcetera)</span><span class="sxs-lookup"><span data-stu-id="47258-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="47258-180">número de píxeles para representar (como)</span><span class="sxs-lookup"><span data-stu-id="47258-180">number of pixels to render (i.e</span></span> <span data-ttu-id="47258-181">resolución de pantalla)</span><span class="sxs-lookup"><span data-stu-id="47258-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="47258-182">Reducir el número de poli</span><span class="sxs-lookup"><span data-stu-id="47258-182">Reduce poly count</span></span>
<span data-ttu-id="47258-183">Polígono mayor cuenta resultado en más operaciones de la GPU y reducir el número de polígonos de la escena se reducirá la cantidad de tiempo para representar ese geometry.</span><span class="sxs-lookup"><span data-stu-id="47258-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="47258-184">Hay otros factores implicados también en el sombreado de la geometría que todavía puede ser costosa, pero recuento polígono es la métrica de base para determinar cuánto cuesta será representar una escena.</span><span class="sxs-lookup"><span data-stu-id="47258-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="47258-185">Límite de sobredibujo</span><span class="sxs-lookup"><span data-stu-id="47258-185">Limit overdraw</span></span>

<span data-ttu-id="47258-186">Alto sobredibujan se produce cuando varios objetos se representan pero no va a producir en la pantalla como están ocultos de manera occluding, generalmente más cerca de otro objeto.</span><span class="sxs-lookup"><span data-stu-id="47258-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="47258-187">Imagine que examina una pared que tenía varias salas y geometría detrás de él.</span><span class="sxs-lookup"><span data-stu-id="47258-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="47258-188">Todos de la geometría se procesarán para la representación, pero sólo la pared opaca realmente debe representarse como lo occludes la vista de todo el contenido.</span><span class="sxs-lookup"><span data-stu-id="47258-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="47258-189">Esto da como resultado una pérdida de tiempo operaciones que no son necesarios para la vista actual.</span><span class="sxs-lookup"><span data-stu-id="47258-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="47258-190">Sombreadores</span><span class="sxs-lookup"><span data-stu-id="47258-190">Shaders</span></span>

<span data-ttu-id="47258-191">Los sombreadores son pequeños programas que se ejecutan en la GPU y generalmente determinan dos pasos importantes en la representación:</span><span class="sxs-lookup"><span data-stu-id="47258-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="47258-192">los vértices de qué objeto se deben dibujar en la pantalla y donde se encuentran en el espacio de pantalla (como)</span><span class="sxs-lookup"><span data-stu-id="47258-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="47258-193">el sombreador de vértices)</span><span class="sxs-lookup"><span data-stu-id="47258-193">the Vertex shader)</span></span>
    - <span data-ttu-id="47258-194">El sombreador de vértices por lo general se ejecuta por vértice para cada GameObject</span><span class="sxs-lookup"><span data-stu-id="47258-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="47258-195">¿Qué colorear los píxeles (como)</span><span class="sxs-lookup"><span data-stu-id="47258-195">what to color those pixels (i.e</span></span> <span data-ttu-id="47258-196">el sombreador de píxeles)</span><span class="sxs-lookup"><span data-stu-id="47258-196">the Pixel shader)</span></span>
    - <span data-ttu-id="47258-197">Se ejecuta el sombreador de píxeles por píxel de la textura que se va a representar para el dispositivo presente</span><span class="sxs-lookup"><span data-stu-id="47258-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="47258-198">Normalmente, los sombreadores realizan muchas transformaciones y cálculos de iluminación.</span><span class="sxs-lookup"><span data-stu-id="47258-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="47258-199">Aunque los modelos de iluminación complejas, sombras y otras operaciones pueden generar resultados fantásticos, también vienen con un precio.</span><span class="sxs-lookup"><span data-stu-id="47258-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="47258-200">Reducir el número de operaciones calculadas en los sombreadores puede reducir considerablemente el trabajo total que se debe realizar una GPU por fotograma.</span><span class="sxs-lookup"><span data-stu-id="47258-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="47258-201">Sombreador de recomendaciones de codificación</span><span class="sxs-lookup"><span data-stu-id="47258-201">Shader coding recommendations</span></span>

- <span data-ttu-id="47258-202">Usar el filtrado bilineal siempre que sea posible</span><span class="sxs-lookup"><span data-stu-id="47258-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="47258-203">Reorganizar las expresiones para usar funciones intrínsecas DESENFRENADAS con el fin de realizar una multiplicación y una adición al mismo tiempo</span><span class="sxs-lookup"><span data-stu-id="47258-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="47258-204">Precalculan tanto como sea posible en la CPU y pasar como constantes al material</span><span class="sxs-lookup"><span data-stu-id="47258-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="47258-205">**Favorecer mover las operaciones desde el sombreador de píxeles para el sombreador de vértices**</span><span class="sxs-lookup"><span data-stu-id="47258-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="47258-206">Por lo general, el número de vértices << número de píxeles (como)</span><span class="sxs-lookup"><span data-stu-id="47258-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="47258-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span><span class="sxs-lookup"><span data-stu-id="47258-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="47258-208">Quitar fases GPU</span><span class="sxs-lookup"><span data-stu-id="47258-208">Remove GPU stages</span></span>
<span data-ttu-id="47258-209">Posprocesamiento efectos puede resultar muy caro y normalmente inhibir la tasa de relleno de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="47258-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="47258-210">Esto también incluye técnicas de suavizado de contorno como MSAA.</span><span class="sxs-lookup"><span data-stu-id="47258-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="47258-211">En HoloLens, se recomienda para evitar estas técnicas completamente.</span><span class="sxs-lookup"><span data-stu-id="47258-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="47258-212">Además, fases del sombreador adicionales como la geometría, casco y los sombreadores de cálculo deben evitarse siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="47258-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="47258-213">Recomendaciones de memoria</span><span class="sxs-lookup"><span data-stu-id="47258-213">Memory recommendations</span></span>
<span data-ttu-id="47258-214">Las operaciones de asignación y desasignación de memoria excesivo pueden tener efectos adversos sobre su aplicación holográfica, dando como resultado un rendimiento incoherente, marcos inmovilizados y otro comportamiento perjudicial.</span><span class="sxs-lookup"><span data-stu-id="47258-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="47258-215">Es especialmente importante entender las consideraciones de memoria al desarrollar en Unity, puesto que la administración de memoria se controla mediante el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="47258-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="47258-216">Agrupación de objetos</span><span class="sxs-lookup"><span data-stu-id="47258-216">Object pooling</span></span>

<span data-ttu-id="47258-217">Agrupación de objetos es una técnica popular para reducir el costo de las asignaciones continua y las cancelaciones de asignación de objetos.</span><span class="sxs-lookup"><span data-stu-id="47258-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="47258-218">Esto se hace mediante la asignación de un grupo grande de objetos idénticos y volver a usar las instancias inactivas, disponibles desde este grupo en lugar de generar constantemente y destruir objetos con el tiempo.</span><span class="sxs-lookup"><span data-stu-id="47258-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="47258-219">Los grupos de objetos son excelentes para los componentes puedan volver a utilizar con duración de la variable durante una aplicación.</span><span class="sxs-lookup"><span data-stu-id="47258-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="47258-220">Vea también</span><span class="sxs-lookup"><span data-stu-id="47258-220">See also</span></span>
- [<span data-ttu-id="47258-221">Recomendaciones de rendimiento para Unity</span><span class="sxs-lookup"><span data-stu-id="47258-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="47258-222">Configuración recomendada para Unity</span><span class="sxs-lookup"><span data-stu-id="47258-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
