---
title: Recomendaciones de rendimiento para Unity
description: Sugerencias específicas de Unity para mejorar el rendimiento con aplicaciones de realidad mixta.
author: troy-ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: gráficos, CPU, GPU, representación, recolección de elementos no utilizados, hololens
ms.localizationpriority: high
ms.openlocfilehash: 28f09986cdb8c562aedfc9deae7b0369214ebc05
ms.sourcegitcommit: d6ac8f1f545fe20cf1e36b83c0e7998b82fd02f8
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/14/2020
ms.locfileid: "81277573"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="bf597-104">Recomendaciones de rendimiento para Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="bf597-105">Este artículo se basa en la explicación que se indica en las [recomendaciones de rendimiento para la realidad mixta](understanding-performance-for-mixed-reality.md), pero se centra en los conocimientos específicos del entorno del motor Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="bf597-106">Uso de la configuración del proyecto de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="bf597-107">El primer paso más importante al optimizar el rendimiento de las aplicaciones de realidad mixta en Unity es asegurarse de que estás usando la [configuración de entorno recomendada para Unity](recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="bf597-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you are using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="bf597-108">En este artículo se incluye contenido con algunas de las configuraciones de escenas más importantes para la creación de aplicaciones de realidad mixta de gran rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="bf597-109">Algunas de estas configuraciones recomendadas también se indican a continuación.</span><span class="sxs-lookup"><span data-stu-id="bf597-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="bf597-110">Cómo generar perfiles con Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-110">How to profile with Unity</span></span>

<span data-ttu-id="bf597-111">Unity proporciona una instancia integrada de **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** , que es un excelente recurso para recopilar información valiosa sobre el rendimiento de tu aplicación en particular.</span><span class="sxs-lookup"><span data-stu-id="bf597-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="bf597-112">Aunque se puede ejecutar Profiler en el editor, estas métricas no representan el entorno real en tiempo de ejecución y, por tanto, los resultados se deben usar con precaución.</span><span class="sxs-lookup"><span data-stu-id="bf597-112">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="bf597-113">Se recomienda generar perfiles de la aplicación de forma remota, mientras se ejecuta en el dispositivo, para obtener una información más precisa y útil.</span><span class="sxs-lookup"><span data-stu-id="bf597-113">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="bf597-114">Además, [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) de Unity también es una herramienta muy eficaz y de información que se puede utilizar.</span><span class="sxs-lookup"><span data-stu-id="bf597-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="bf597-115">Unity proporciona una documentación excelente sobre:</span><span class="sxs-lookup"><span data-stu-id="bf597-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="bf597-116">Cómo conectar [Unity Profiler a aplicaciones para UWP de forma remota](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="bf597-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="bf597-117">Cómo [diagnosticar los problemas de rendimiento con Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window) de forma eficaz</span><span class="sxs-lookup"><span data-stu-id="bf597-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="bf597-118">Con Unity Profiler conectado y después de agregar el generador de perfiles de GPU (consulta *Agregar generador de perfiles* en la esquina superior derecha), puedes ver cuánto tiempo se dedica a CPU y a GPU, respectivamente, en medio del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="bf597-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="bf597-119">Esto permite al desarrollador obtener una aproximación rápida de si su aplicación está vinculada a la CPU o la GPU.</span><span class="sxs-lookup"><span data-stu-id="bf597-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU de Unity frente a GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="bf597-121">Recomendaciones de rendimiento de CPU</span><span class="sxs-lookup"><span data-stu-id="bf597-121">CPU performance recommendations</span></span>

<span data-ttu-id="bf597-122">El siguiente contenido abarca prácticas de rendimiento más detalladas, especialmente destinadas al desarrollo en Unity y C#.</span><span class="sxs-lookup"><span data-stu-id="bf597-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="bf597-123">Almacenamiento en caché de referencias</span><span class="sxs-lookup"><span data-stu-id="bf597-123">Cache references</span></span>

<span data-ttu-id="bf597-124">Es una buena práctica almacenar en caché las referencias para todos los componentes pertinentes y GameObjects en la inicialización.</span><span class="sxs-lookup"><span data-stu-id="bf597-124">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="bf597-125">Esto se debe a que las llamadas a funciones repetitivas, como *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* son considerablemente más costosas en relación con el costo de memoria para almacenar un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf597-125">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="bf597-126">Esto también se aplica a [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html) que se usa con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="bf597-126">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="bf597-127">*Camera.main* en realidad solo usa *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* debajo, que busca de un modo costoso en el gráfico de la escena un objeto de cámara con la etiqueta *"MainCamera"* .</span><span class="sxs-lookup"><span data-stu-id="bf597-127">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="bf597-128">Evita GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="bf597-128">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="bf597-129">Al usar *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , se producen unas cuantas sobrecargas diferentes.</span><span class="sxs-lookup"><span data-stu-id="bf597-129">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="bf597-130">Es importante usar siempre las implementaciones basadas en tipo y nunca la sobrecarga de búsqueda basada en cadena.</span><span class="sxs-lookup"><span data-stu-id="bf597-130">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="bf597-131">La búsqueda por cadena en la escena es significativamente más costosa que la búsqueda por tipo.</span><span class="sxs-lookup"><span data-stu-id="bf597-131">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="bf597-132">(Correcto) Component GetComponent(Type tipo)</span><span class="sxs-lookup"><span data-stu-id="bf597-132">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="bf597-133">(Correcto) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="bf597-133">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="bf597-134">(Incorrecto) Component GetComponent(string)></span><span class="sxs-lookup"><span data-stu-id="bf597-134">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="bf597-135">Evita operaciones costosas</span><span class="sxs-lookup"><span data-stu-id="bf597-135">Avoid expensive operations</span></span>

1) <span data-ttu-id="bf597-136">**Evita el uso de [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="bf597-136">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="bf597-137">Aunque LINQ puede ser muy limpio y fácil de leer y escribir, generalmente requiere mucho más cálculo y, en particular, más asignación de memoria que escribir el algoritmo de forma manual.</span><span class="sxs-lookup"><span data-stu-id="bf597-137">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="bf597-138">**API comunes de Unity**</span><span class="sxs-lookup"><span data-stu-id="bf597-138">**Common Unity APIs**</span></span>

    <span data-ttu-id="bf597-139">Ciertas API de Unity, aunque resultan útiles, pueden ser muy costosas de ejecutar.</span><span class="sxs-lookup"><span data-stu-id="bf597-139">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="bf597-140">La mayoría de ellas implican buscar, en todo el gráfico de escena, una lista de GameObjects coincidentes.</span><span class="sxs-lookup"><span data-stu-id="bf597-140">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="bf597-141">Por lo general, estas operaciones se pueden evitar mediante el almacenamiento en caché de las referencias o la implementación de un componente administrador para los GameObjects en cuestión, a fin de realizar el seguimiento de las referencias en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bf597-141">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="bf597-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* y *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* deben eliminarse a toda costa.</span><span class="sxs-lookup"><span data-stu-id="bf597-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="bf597-143">Estas funciones pueden ser del orden de 1000 veces más lentas que las llamadas a funciones directas.</span><span class="sxs-lookup"><span data-stu-id="bf597-143">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="bf597-144">**Ten cuidado con la conversión boxing**</span><span class="sxs-lookup"><span data-stu-id="bf597-144">**Beware of boxing**</span></span>

    <span data-ttu-id="bf597-145">[La conversión boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) es un concepto básico del lenguaje C# y del tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bf597-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="bf597-146">Es el proceso de encapsular variables con tipo de valor como char, int, bool, etc. en variables con tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="bf597-146">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="bf597-147">Cuando a una variable con tipo de valor se le aplica la "conversión boxing", se encapsula dentro de un objeto System.Object que se almacena en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="bf597-147">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="bf597-148">Por lo tanto, se asigna memoria y, en el momento en el que se elimina, el recolector de elementos no utilizados la debe procesar.</span><span class="sxs-lookup"><span data-stu-id="bf597-148">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="bf597-149">Estas asignaciones y anulaciones de asignación incurren en un costo de rendimiento y en muchos escenarios no son necesarias o se pueden reemplazar fácilmente por una alternativa menos costosa.</span><span class="sxs-lookup"><span data-stu-id="bf597-149">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="bf597-150">Una de las formas más comunes de conversión boxing en el desarrollo es el uso de [tipos de valor que aceptan valores NULL](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="bf597-150">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="bf597-151">Es habitual querer tener la posibilidad de devolver null para un tipo de valor en una función, sobre todo cuando la operación puede producir un error al intentar obtener el valor.</span><span class="sxs-lookup"><span data-stu-id="bf597-151">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="bf597-152">El posible problema con este enfoque es que la asignación se produce ahora en el montón y, por consiguiente, debe recolectarse como elemento no utilizado más adelante.</span><span class="sxs-lookup"><span data-stu-id="bf597-152">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="bf597-153">**Ejemplo de conversión boxing en C#**</span><span class="sxs-lookup"><span data-stu-id="bf597-153">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="bf597-154">**Ejemplo de conversión boxing problemática mediante tipos de valor que aceptan valores NULL**</span><span class="sxs-lookup"><span data-stu-id="bf597-154">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="bf597-155">Este código muestra una clase de partícula ficticia que se puede crear en un proyecto de Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-155">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="bf597-156">Una llamada a `TryGetSpeed()` producirá la asignación de objetos en el montón que se deberán recolectar como elementos no utilizados en un momento posterior.</span><span class="sxs-lookup"><span data-stu-id="bf597-156">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="bf597-157">Este ejemplo es especialmente problemático, ya que puede haber 1000 o más partículas en una escena, a cada una de las cuales se solicita su velocidad actual.</span><span class="sxs-lookup"><span data-stu-id="bf597-157">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="bf597-158">Por lo tanto, se asignarán miles de objetos y, por consiguiente, se anulará su asignación en cada fotograma, lo que reducirá considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-158">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="bf597-159">Volver a escribir la función para devolver un valor negativo como -1 para indicar un error evitará este problema y conservará la memoria en la pila.</span><span class="sxs-lookup"><span data-stu-id="bf597-159">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="bf597-160">Rutas de acceso al código repetitivas</span><span class="sxs-lookup"><span data-stu-id="bf597-160">Repeating code paths</span></span>

<span data-ttu-id="bf597-161">Cualquier función de devolución de llamada de Unity repetitiva (por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="bf597-161">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="bf597-162">Update) que se ejecuta muchas veces por segundo o fotograma debe escribirse con sumo cuidado.</span><span class="sxs-lookup"><span data-stu-id="bf597-162">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="bf597-163">Cualquier operación costosa tendrá un impacto enorme y consistente en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-163">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="bf597-164">**Funciones de devolución de llamada vacías**</span><span class="sxs-lookup"><span data-stu-id="bf597-164">**Empty callback functions**</span></span>

    <span data-ttu-id="bf597-165">Aunque pueda parecer inofensivo dejar el código siguiente en la aplicación, sobre todo porque cada script de Unity se inicializa automáticamente con este bloque de código, estas devoluciones de llamada vacías pueden llegar a ser muy costosas.</span><span class="sxs-lookup"><span data-stu-id="bf597-165">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="bf597-166">Unity opera de un lado para otro de un límite de código administrado o no administrado, entre el código UnityEngine y el código de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-166">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="bf597-167">El cambio de contexto sobre este puente es bastante caro, incluso si no hay nada que ejecutar.</span><span class="sxs-lookup"><span data-stu-id="bf597-167">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="bf597-168">Resulta especialmente problemático si la aplicación tiene cientos de objetos GameObject con componentes que tienen devoluciones de llamada vacías de Unity repetitivas.</span><span class="sxs-lookup"><span data-stu-id="bf597-168">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="bf597-169">Update () es la manifestación más común de este problema de rendimiento, pero otras devoluciones de llamada de Unity repetitivas, como las siguientes, pueden ser igual de perjudiciales, si no peores: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="bf597-169">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="bf597-170">**Operaciones para favorecer una ejecución por fotograma**</span><span class="sxs-lookup"><span data-stu-id="bf597-170">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="bf597-171">Las siguientes API de Unity son operaciones comunes para muchas aplicaciones holográficas.</span><span class="sxs-lookup"><span data-stu-id="bf597-171">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="bf597-172">Aunque no siempre es posible, los resultados de estas funciones se suelen calcular una vez y los resultados se reutilizan en la aplicación para un fotograma determinado.</span><span class="sxs-lookup"><span data-stu-id="bf597-172">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="bf597-173">a) Por lo general, es una buena práctica tener una clase o un servicio Singleton dedicado para controlar la mirada Raycast de la escena y, a continuación, volver a usar este resultado en todos los demás componentes de la escena, en lugar de realizar repetidas operaciones Raycast y esencialmente idénticas para cada componente.</span><span class="sxs-lookup"><span data-stu-id="bf597-173">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="bf597-174">Por supuesto, es posible que algunas aplicaciones requieran Raycast de distintos orígenes o con diferentes[LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="bf597-174">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="bf597-175">b) Evita las operaciones GetComponent() en las devoluciones de llamada de Unity repetitivas, como Update(), mediante el [almacenamiento en caché de referencias](#cache-references) en Start() o Awake()</span><span class="sxs-lookup"><span data-stu-id="bf597-175">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="bf597-176">c) Es una buena práctica crear instancias de todos los objetos, si es posible, en la inicialización y usar la [agrupación de objetos](#object-pooling) para reciclar y volver a usar GameObjects durante todo el tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-176">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="bf597-177">**Evita interfaces y construcciones virtuales**</span><span class="sxs-lookup"><span data-stu-id="bf597-177">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="bf597-178">La invocación de llamadas a funciones a través de interfaces frente a objetos directos o la llamada a funciones virtuales pueden ser a menudo mucho más costosas que usar construcciones directas o llamadas a funciones directas.</span><span class="sxs-lookup"><span data-stu-id="bf597-178">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="bf597-179">Si la interfaz o función virtual no es necesaria, se debe quitar.</span><span class="sxs-lookup"><span data-stu-id="bf597-179">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="bf597-180">Sin embargo, por lo general, el impacto en el rendimiento de estos enfoques merece la pena si su uso simplifica la colaboración en el desarrollo, la legibilidad del código y el mantenimiento del código.</span><span class="sxs-lookup"><span data-stu-id="bf597-180">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="bf597-181">Por lo general, la recomendación es no marcar los campos y las funciones como virtuales a menos que haya una expectativa clara de que sea necesario sobrescribir este miembro.</span><span class="sxs-lookup"><span data-stu-id="bf597-181">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="bf597-182">Se debe ser especialmente cauto en torno a las rutas de acceso del código de alta frecuencia a las que se llama muchas veces por fotograma, o incluso una vez por fotograma, como un método `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="bf597-182">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="bf597-183">**Evita pasar estructuras por valor**</span><span class="sxs-lookup"><span data-stu-id="bf597-183">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="bf597-184">A diferencia de las clases, las estructuras son tipos de valor y, cuando se pasan directamente a una función, su contenido se copia en una instancia recién creada.</span><span class="sxs-lookup"><span data-stu-id="bf597-184">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="bf597-185">Esta copia agrega costo de CPU, así como memoria adicional a la pila.</span><span class="sxs-lookup"><span data-stu-id="bf597-185">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="bf597-186">En el caso de las estructuras pequeñas, el efecto es normalmente mínimo y, por tanto, aceptable.</span><span class="sxs-lookup"><span data-stu-id="bf597-186">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="bf597-187">Sin embargo, para las funciones invocadas repetidamente en cada fotograma y las funciones que toman estructuras grandes, si es posible, modifica la definición de función para que pase por referencia.</span><span class="sxs-lookup"><span data-stu-id="bf597-187">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="bf597-188">Obtén más información aquí</span><span class="sxs-lookup"><span data-stu-id="bf597-188">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="bf597-189">Varios</span><span class="sxs-lookup"><span data-stu-id="bf597-189">Miscellaneous</span></span>

1) <span data-ttu-id="bf597-190">**Física**</span><span class="sxs-lookup"><span data-stu-id="bf597-190">**Physics**</span></span>

    <span data-ttu-id="bf597-191">a) En general, la manera más fácil de mejorar la física es limitar la cantidad de tiempo empleado en la física o el número de iteraciones por segundo.</span><span class="sxs-lookup"><span data-stu-id="bf597-191">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="bf597-192">Por supuesto, disminuirá la precisión de la simulación.</span><span class="sxs-lookup"><span data-stu-id="bf597-192">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="bf597-193">Consulta [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) en Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-193">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="bf597-194">b) El tipo de colisionadores en Unity tiene características de rendimiento muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="bf597-194">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="bf597-195">En el orden siguiente se indican los colisionadores de mayor rendimiento a los colisionadores con menor rendimiento, de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="bf597-195">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="bf597-196">Es de suma importancia evitar los colisionadores de malla, que son mucho más caros que los colisionadores primitivos.</span><span class="sxs-lookup"><span data-stu-id="bf597-196">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="bf597-197">Consulta [Buenas prácticas de la física de Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="bf597-197">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="bf597-198">**Animaciones**</span><span class="sxs-lookup"><span data-stu-id="bf597-198">**Animations**</span></span>

    <span data-ttu-id="bf597-199">Deshabilita las animaciones inactivas deshabilitando el componente animador (la deshabilitación del objeto de juego no tendrá el mismo efecto).</span><span class="sxs-lookup"><span data-stu-id="bf597-199">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="bf597-200">Evita patrones de diseño en los que un animador se encuentre en un bucle estableciendo un valor en lo mismo.</span><span class="sxs-lookup"><span data-stu-id="bf597-200">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="bf597-201">Esta técnica conlleva una sobrecarga considerable, sin ningún efecto en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-201">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="bf597-202">Obtén más información aquí.</span><span class="sxs-lookup"><span data-stu-id="bf597-202">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="bf597-203">**Algoritmos complejos**</span><span class="sxs-lookup"><span data-stu-id="bf597-203">**Complex algorithms**</span></span>

    <span data-ttu-id="bf597-204">Si tu aplicación usa algoritmos complejos, como la cinemática inversa, la búsqueda de rutas de acceso, etc., busca un enfoque más sencillo o ajusta los valores de configuración pertinentes para su rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-204">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="bf597-205">Recomendaciones de rendimiento de CPU a GPU</span><span class="sxs-lookup"><span data-stu-id="bf597-205">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="bf597-206">En general, el rendimiento de CPU a GPU baja hasta las **llamadas a draw** enviadas a la tarjeta gráfica.</span><span class="sxs-lookup"><span data-stu-id="bf597-206">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="bf597-207">Para mejorar el rendimiento, las llamadas a draw se deben **a)** reducir o **b) reestructurar** estratégicamente para obtener resultados óptimos.</span><span class="sxs-lookup"><span data-stu-id="bf597-207">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="bf597-208">Dado que las llamadas a draw en sí mismas usan una gran cantidad de recursos, reducirlas también reducirá el trabajo general necesario.</span><span class="sxs-lookup"><span data-stu-id="bf597-208">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="bf597-209">Además, los cambios de estado entre llamadas a draw requieren pasos de validación y traducción costosos en el controlador de gráficos y, por lo tanto, la reestructuración de las llamadas a draw de la aplicación para limitar los cambios de estado (es decir,</span><span class="sxs-lookup"><span data-stu-id="bf597-209">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="bf597-210">distintos materiales, etc.) puede mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-210">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="bf597-211">Unity dispone de un excelente artículo que proporciona información general y profundiza en el procesamiento por lotes de las llamadas a draw para su plataforma.</span><span class="sxs-lookup"><span data-stu-id="bf597-211">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="bf597-212">Procesamiento por lotes de llamadas a draw de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-212">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="bf597-213">Representación con instancia de un solo paso</span><span class="sxs-lookup"><span data-stu-id="bf597-213">Single pass instanced rendering</span></span>

<span data-ttu-id="bf597-214">La representación con instancia de un solo paso en Unity permite que las llamadas a draw de cada ojo se reduzcan a una llamada a draw con instancia.</span><span class="sxs-lookup"><span data-stu-id="bf597-214">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="bf597-215">Debido a la coherencia de la memoria caché entre dos llamadas a draw, también hay una mejora del rendimiento de la GPU.</span><span class="sxs-lookup"><span data-stu-id="bf597-215">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="bf597-216">Para habilitar esta característica en el proyecto de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-216">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="bf597-217">Abre **Player XR Settings** (Configuración del reproductor XR) (ve a **Editar** > **Configuración del proyecto** > **Reproductor** > **XR Settings** [Configuración de XR]).</span><span class="sxs-lookup"><span data-stu-id="bf597-217">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="bf597-218">Selecciona **Single Pass Instanced** (Con instancia de un solo paso) en el menú desplegable **Stereo Rendering Method** (Método de representación en estéreo) (la casilla **Virtual Reality Supported** [Compatibilidad con realidad virtual] debe estar marcada)</span><span class="sxs-lookup"><span data-stu-id="bf597-218">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="bf597-219">Lee los siguientes artículos de Unity para obtener más información sobre este enfoque de representación.</span><span class="sxs-lookup"><span data-stu-id="bf597-219">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="bf597-220">Cómo maximizar el rendimiento de AR y VR con la representación en estéreo avanzada</span><span class="sxs-lookup"><span data-stu-id="bf597-220">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="bf597-221">Creación de instancias de un solo paso</span><span class="sxs-lookup"><span data-stu-id="bf597-221">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="bf597-222">Un problema común con la representación con instancia de un solo paso se produce si los desarrolladores ya tienen sombreadores personalizados no escritos para la creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="bf597-222">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="bf597-223">Después de habilitar esta característica, los desarrolladores pueden observar que algunos objetos GameObjects solo se representan en un ojo.</span><span class="sxs-lookup"><span data-stu-id="bf597-223">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="bf597-224">Esto se debe a que los sombreadores personalizados asociados no tienen las propiedades adecuadas para la creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="bf597-224">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="bf597-225">Consulta [Representación en estéreo de un solo paso para HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) de Unity para solucionar este problema.</span><span class="sxs-lookup"><span data-stu-id="bf597-225">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="bf597-226">Procesamiento por lotes estático</span><span class="sxs-lookup"><span data-stu-id="bf597-226">Static batching</span></span>

<span data-ttu-id="bf597-227">Unity puede procesar por lotes muchos objetos estáticos para reducir las llamadas draw a la GPU.</span><span class="sxs-lookup"><span data-stu-id="bf597-227">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="bf597-228">El procesamiento por lotes estático funciona en la mayoría de los objetos [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) en Unity que **1) comparten el mismo material** y **2) todos están marcados como *estáticos*** (selecciona un objeto en Unity y haz clic en la casilla de la parte superior derecha del inspector).</span><span class="sxs-lookup"><span data-stu-id="bf597-228">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="bf597-229">Los objetos GameObject marcados como *estáticos* no se pueden mover en tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-229">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="bf597-230">Por lo tanto, el procesamiento por lotes estático puede ser difícil de utilizar en HoloLens, donde prácticamente todos los objetos deben colocarse, moverse, escalarse, etc. En el caso de los cascos envolventes, el procesamiento por lotes estático puede reducir drásticamente las llamadas a draw y mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-230">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="bf597-231">Lee *Procesamiento por lotes estático* en [Procesamiento por lotes de llamadas a draw en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="bf597-231">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="bf597-232">Procesamiento por lotes dinámico</span><span class="sxs-lookup"><span data-stu-id="bf597-232">Dynamic batching</span></span>

<span data-ttu-id="bf597-233">Dado que es problemático marcar objetos como *estáticos* para el desarrollo de HoloLens, el procesamiento por lotes dinámico puede ser una herramienta excelente para compensar esta característica que falta.</span><span class="sxs-lookup"><span data-stu-id="bf597-233">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="bf597-234">Por supuesto, también puede ser útil en los cascos envolventes.</span><span class="sxs-lookup"><span data-stu-id="bf597-234">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="bf597-235">Sin embargo, el procesamiento por lotes dinámico en Unity puede ser difícil de habilitar porque los objetos GameObject deben **a) compartir el mismo material** y **b) cumplir una larga lista de otros criterios**.</span><span class="sxs-lookup"><span data-stu-id="bf597-235">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="bf597-236">Lee *Procesamiento por lotes dinámico* en [Procesamiento por lotes de llamadas a draw en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obtener la lista completa.</span><span class="sxs-lookup"><span data-stu-id="bf597-236">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="bf597-237">Normalmente, los objetos GameObject dejan de ser válidos para el procesamiento por lotes dinámico, porque los datos de malla asociados no pueden ser más de 300 vértices.</span><span class="sxs-lookup"><span data-stu-id="bf597-237">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="bf597-238">Otras técnicas</span><span class="sxs-lookup"><span data-stu-id="bf597-238">Other techniques</span></span>

<span data-ttu-id="bf597-239">El procesamiento por lotes solo puede producirse si varios objetos GameObject pueden compartir el mismo material.</span><span class="sxs-lookup"><span data-stu-id="bf597-239">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="bf597-240">Normalmente, se bloqueará por la necesidad de que los objetos GameObject tengan una textura única para su material respectivo.</span><span class="sxs-lookup"><span data-stu-id="bf597-240">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="bf597-241">Es habitual combinar texturas en una sola gran textura, un método conocido como [Creación de atlas de texturas](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="bf597-241">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="bf597-242">Además, suele ser preferible combinar las mallas en un objeto GameObject siempre que sea posible y razonable.</span><span class="sxs-lookup"><span data-stu-id="bf597-242">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="bf597-243">Cada Renderer de Unity tendrá sus llamadas a draw asociadas y enviará una malla combinada bajo un Renderer.</span><span class="sxs-lookup"><span data-stu-id="bf597-243">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="bf597-244">La modificación de las propiedades de Renderer.material en tiempo de ejecución creará una copia del material y, por tanto, puede interrumpir el procesamiento por lotes.</span><span class="sxs-lookup"><span data-stu-id="bf597-244">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="bf597-245">Usa Renderer.sharedMaterial para modificar las propiedades de material compartido en los objetos GameObject.</span><span class="sxs-lookup"><span data-stu-id="bf597-245">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="bf597-246">Recomendaciones de rendimiento de GPU</span><span class="sxs-lookup"><span data-stu-id="bf597-246">GPU performance recommendations</span></span>

<span data-ttu-id="bf597-247">Más información acerca de la [optimización de la representación de gráficos en Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="bf597-247">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="bf597-248">Optimización del uso compartido del búfer de profundidad</span><span class="sxs-lookup"><span data-stu-id="bf597-248">Optimize depth buffer sharing</span></span>

<span data-ttu-id="bf597-249">Por lo general, se recomienda habilitar **Depth buffer sharing** (Uso compartido del búfer de profundidad) en **Player XR Settings** (Configuración del reproductor XR) para optimizar la [estabilidad del holograma](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="bf597-249">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="bf597-250">Sin embargo, al habilitar la reproyección en etapa posterior basada en la profundidad con esta configuración, se recomienda seleccionar el **formato de profundidad de 16 bits** en lugar del **formato de profundidad de 24 bits**.</span><span class="sxs-lookup"><span data-stu-id="bf597-250">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="bf597-251">Los búferes de profundidad de 16 bits reducirán drásticamente el ancho de banda (y, por lo tanto, la energía) asociado con el tráfico del búfer de profundidad.</span><span class="sxs-lookup"><span data-stu-id="bf597-251">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="bf597-252">Puede ser una gran victoria tanto en la reducción de energía como en la mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bf597-252">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="bf597-253">Sin embargo, hay dos posibles resultados negativos al usar el *formato de profundidad de 16 bits*.</span><span class="sxs-lookup"><span data-stu-id="bf597-253">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="bf597-254">**Z-Fighting**</span><span class="sxs-lookup"><span data-stu-id="bf597-254">**Z-Fighting**</span></span>

<span data-ttu-id="bf597-255">La fidelidad del intervalo de profundidad reducida hace que sea más probable que se produzca [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) con 16 bits que con 24 bits.</span><span class="sxs-lookup"><span data-stu-id="bf597-255">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="bf597-256">Para evitar estos artefactos, modifica los planos de recortes cercanos o lejanos de la [cámara de Unity](https://docs.unity3d.com/Manual/class-Camera.html) para tener en cuenta la precisión inferior.</span><span class="sxs-lookup"><span data-stu-id="bf597-256">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="bf597-257">En el caso de las aplicaciones basadas en HoloLens, un plano de recorte lejano de 50 m, en lugar del valor predeterminado de Unity de 1000 m, puede eliminar cualquier z-fighting.</span><span class="sxs-lookup"><span data-stu-id="bf597-257">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="bf597-258">**Búfer de galería de símbolos deshabilitado**</span><span class="sxs-lookup"><span data-stu-id="bf597-258">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="bf597-259">Cuando Unity crea una [representación de textura con profundidad de 16 bits](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), no se crea ningún búfer de galería de símbolos.</span><span class="sxs-lookup"><span data-stu-id="bf597-259">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="bf597-260">Al seleccionar el formato de profundidad de 24 bits, según la documentación de Unity, se creará un búfer Z de 24 bits, así como un [búfer de galería de símbolos de 8 bits] (https://docs.unity3d.com/Manual/SL-Stencil.html) (si se puede aplicar 32 bits en un dispositivo, que suele ser el caso, como HoloLens).</span><span class="sxs-lookup"><span data-stu-id="bf597-260">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="bf597-261">Evita efectos de pantalla completa</span><span class="sxs-lookup"><span data-stu-id="bf597-261">Avoid full-screen effects</span></span>

<span data-ttu-id="bf597-262">Las técnicas que operan en la pantalla completa pueden resultar bastante costosas, ya que su orden de magnitud es millones de operaciones en cada fotograma.</span><span class="sxs-lookup"><span data-stu-id="bf597-262">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="bf597-263">Por lo tanto, se recomienda evitar [efectos posteriores al procesamiento](https://docs.unity3d.com/Manual/PostProcessingOverview.html) como el suavizado de contorno, la eclosión, etc.</span><span class="sxs-lookup"><span data-stu-id="bf597-263">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="bf597-264">Configuración de iluminación óptima</span><span class="sxs-lookup"><span data-stu-id="bf597-264">Optimal lighting settings</span></span>

<span data-ttu-id="bf597-265">La [iluminación global en tiempo real](https://docs.unity3d.com/Manual/GIIntro.html) de Unity puede proporcionar resultados visuales excelentes, pero implica cálculos de iluminación bastante costosos.</span><span class="sxs-lookup"><span data-stu-id="bf597-265">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="bf597-266">Se recomienda deshabilitar la iluminación global en tiempo real para cada archivo de escena de Unity a través de **Ventana** > **Representación** > **Lighting Settings** (Configuración de iluminación) > desmarca **Real-time Global Illumination** (Iluminación global en tiempo real).</span><span class="sxs-lookup"><span data-stu-id="bf597-266">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="bf597-267">Además, se recomienda deshabilitar todas las proyecciones de sombras, ya que también agregan pasadas de GPU costosas a una escena de Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-267">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="bf597-268">Las sombras se pueden deshabilitar por iluminación, pero también se pueden controlar holísticamente a través de la configuración de la calidad.</span><span class="sxs-lookup"><span data-stu-id="bf597-268">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="bf597-269">**Editar** > **Configuración del proyecto**, luego selecciona la categoría **Calidad** > selecciona **Calidad baja** para la Plataforma UWP.</span><span class="sxs-lookup"><span data-stu-id="bf597-269">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="bf597-270">También puedes establecer solo la propiedad **Sombras** en **Disable Shadows** (Deshabilitar sombras).</span><span class="sxs-lookup"><span data-stu-id="bf597-270">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="bf597-271">Reducción del recuento de polígonos</span><span class="sxs-lookup"><span data-stu-id="bf597-271">Reduce poly count</span></span>

<span data-ttu-id="bf597-272">Normalmente, se reduce el número de polígonos mediante alguna de las acciones siguientes</span><span class="sxs-lookup"><span data-stu-id="bf597-272">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="bf597-273">Eliminación de objetos de una escena</span><span class="sxs-lookup"><span data-stu-id="bf597-273">Removing objects from a scene</span></span>
2) <span data-ttu-id="bf597-274">Supresión de recursos, lo que reduce el número de polígonos de una malla determinada</span><span class="sxs-lookup"><span data-stu-id="bf597-274">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="bf597-275">Implementación de un [sistema de nivel de detalle (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) en la aplicación, que represente los objetos alejados con una versión de polígono inferior de la misma geometría</span><span class="sxs-lookup"><span data-stu-id="bf597-275">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="bf597-276">Descripción de los sombreadores en Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-276">Understanding shaders in Unity</span></span>

<span data-ttu-id="bf597-277">Una aproximación sencilla para comparar los sombreadores en el rendimiento es identificar el número promedio de operaciones que cada uno ejecuta en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bf597-277">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="bf597-278">Esto se puede hacer fácilmente en Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-278">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="bf597-279">Selecciona el recurso de sombreador o selecciona un material y, a continuación, en la esquina superior derecha de la ventana del inspector, selecciona el icono de engranaje seguido de **"Select Shader"** (Seleccionar sombreador).</span><span class="sxs-lookup"><span data-stu-id="bf597-279">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Selección del sombreador en Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="bf597-281">Con el recurso de sombreador seleccionado, haz clic en el botón **"Compile and show code"** (Compilar y mostrar código) en la ventana del inspector.</span><span class="sxs-lookup"><span data-stu-id="bf597-281">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilación del código de sombreador en Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="bf597-283">Después de la compilación, busca la sección de estadísticas en los resultados con el número de las diferentes operaciones para el sombreador de vértices y píxeles. (Nota: Los sombreadores de píxeles se suelen denominar sombreadores de fragmentos).</span><span class="sxs-lookup"><span data-stu-id="bf597-283">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operaciones del sombreador estándar de Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="bf597-285">Optimización de los sombreadores de píxeles</span><span class="sxs-lookup"><span data-stu-id="bf597-285">Optimize pixel shaders</span></span>

<span data-ttu-id="bf597-286">Si se examinan los resultados de las estadísticas compiladas con el método anterior, el [sombreador de fragmentos](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) ejecutará normalmente más operaciones que el [sombreador de vértices](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), como promedio.</span><span class="sxs-lookup"><span data-stu-id="bf597-286">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="bf597-287">El sombreador de fragmentos, también conocido como sombreador de píxeles, se ejecuta por píxel en la salida de la pantalla, mientras que el sombreador de vértices solo se ejecuta por vértice de todas las mallas que se dibujan en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="bf597-287">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="bf597-288">Por lo tanto, no solo los sombreadores de fragmentos tienen más instrucciones que los sombreadores de vértices debido a todos los cálculos de iluminación, los sombreadores de fragmentos casi siempre se ejecutan en un conjunto de datos mayor.</span><span class="sxs-lookup"><span data-stu-id="bf597-288">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="bf597-289">Por ejemplo, si la salida de la pantalla es una imagen de 2 K por 2 K, el sombreador de fragmentos puede ejecutarse 2000 \* 2000 = 4 000 000 veces.</span><span class="sxs-lookup"><span data-stu-id="bf597-289">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="bf597-290">Si se representan dos ojos, este número se duplica ya que hay dos pantallas.</span><span class="sxs-lookup"><span data-stu-id="bf597-290">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="bf597-291">Si una aplicación de realidad mixta tiene varios pasos, efectos de procesamiento posterior de pantalla completa o representación de varias mallas para el mismo píxel, este número aumentará drásticamente.</span><span class="sxs-lookup"><span data-stu-id="bf597-291">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="bf597-292">Por lo tanto, reducir el número de operaciones en el sombreador de fragmentos normalmente puede proporcionar mejoras de rendimiento mucho mayores que las optimizaciones del sombreador de vértices.</span><span class="sxs-lookup"><span data-stu-id="bf597-292">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="bf597-293">Alternativas del sombreador estándar de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-293">Unity Standard shader alternatives</span></span>

<span data-ttu-id="bf597-294">En lugar de usar una representación basada físicamente (PBR) u otro sombreador de alta calidad, consulta el uso de un sombreador más eficaz y económico.</span><span class="sxs-lookup"><span data-stu-id="bf597-294">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="bf597-295">[Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) proporciona el [sombreador estándar de MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) que se ha optimizado para proyectos de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="bf597-295">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="bf597-296">Unity también proporciona opciones sin iluminación, iluminación de vértice, difuso y otras opciones simplificadas de sombreador que son mucho más rápidas en comparación con el sombreador estándar de Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-296">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="bf597-297">Consulta [Uso y rendimiento de los sombreadores integrados](https://docs.unity3d.com/Manual/shader-Performance.html) para obtener información más detallada.</span><span class="sxs-lookup"><span data-stu-id="bf597-297">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="bf597-298">Precarga de sombreador</span><span class="sxs-lookup"><span data-stu-id="bf597-298">Shader preloading</span></span>

<span data-ttu-id="bf597-299">Usa la *precarga del sombreador* y otros trucos para optimizar el [tiempo de carga del sombreador](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="bf597-299">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="bf597-300">En concreto, la precarga del sombreador significa que no verás ningún problema debido a la compilación del sombreador en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bf597-300">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="bf597-301">Sobredibujo del límite</span><span class="sxs-lookup"><span data-stu-id="bf597-301">Limit overdraw</span></span>

<span data-ttu-id="bf597-302">En Unity, se puede mostrar el sobredibujo de la escena, alternando el [**menú de modo de dibujo**](https://docs.unity3d.com/Manual/ViewModes.html) en la esquina superior izquierda de **Scene view** (Vista de escena) y seleccionando **Overdraw** (Sobredibujar).</span><span class="sxs-lookup"><span data-stu-id="bf597-302">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="bf597-303">Por lo general, el sobredibujo se puede mitigar eliminando los objetos antes de enviarlos a la GPU.</span><span class="sxs-lookup"><span data-stu-id="bf597-303">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="bf597-304">Unity proporciona información detallada sobre la implementación de la [Eliminación de oclusión](https://docs.unity3d.com/Manual/OcclusionCulling.html) para su motor.</span><span class="sxs-lookup"><span data-stu-id="bf597-304">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="bf597-305">Recomendaciones de memoria</span><span class="sxs-lookup"><span data-stu-id="bf597-305">Memory recommendations</span></span>

<span data-ttu-id="bf597-306">Un número excesivo de operaciones de asignación y anulación de asignación de memoria puede tener efectos negativos en la aplicación holográfica, lo que produce un rendimiento incoherente, fotogramas inmovilizados y otro comportamiento perjudicial.</span><span class="sxs-lookup"><span data-stu-id="bf597-306">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="bf597-307">Es especialmente importante comprender las consideraciones de memoria al desarrollar en Unity, ya que la administración de la memoria se controla mediante el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="bf597-307">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="bf597-308">Recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="bf597-308">Garbage collection</span></span>

<span data-ttu-id="bf597-309">Las aplicaciones holográficas perderán tiempo de cálculo de procesamiento en el recolector de elementos no utilizados (GC) cuando se active el GC para analizar los objetos que ya no están en el ámbito durante la ejecución y se deba liberar su memoria, a fin de que pueda estar disponible para su reutilización.</span><span class="sxs-lookup"><span data-stu-id="bf597-309">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="bf597-310">Normalmente, las constantes asignaciones y anulaciones de asignación requerirán que el recolector de elementos no utilizados se ejecute con más frecuencia, con lo que se perjudica el rendimiento y la experiencia del usuario.</span><span class="sxs-lookup"><span data-stu-id="bf597-310">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="bf597-311">Unity ha proporcionado una página excelente que explica con detalle cómo funciona el recolector de elementos no utilizados y las sugerencias para escribir código más eficaz en lo que respecta a la administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="bf597-311">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="bf597-312">Optimización de la recolección de elementos no utilizados en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-312">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="bf597-313">Una de las prácticas más comunes que conduce a una recolección excesiva de elementos no utilizados es no almacenar en caché las referencias para componentes y clases del desarrollo de Unity.</span><span class="sxs-lookup"><span data-stu-id="bf597-313">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="bf597-314">Las referencias deben capturarse durante las funciones Start() o Awake() y se pueden volver a usar en funciones posteriores como Update() o LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="bf597-314">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="bf597-315">Otras sugerencias rápidas:</span><span class="sxs-lookup"><span data-stu-id="bf597-315">Other quick tips:</span></span>
- <span data-ttu-id="bf597-316">Usa la clase [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) de C# para generar dinámicamente cadenas complejas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bf597-316">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="bf597-317">Quita las llamadas a Debug.log() cuando ya no sean necesarias, ya que se ejecutan en todas las versiones de compilación de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-317">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="bf597-318">Si la aplicación holográfica normalmente requiere una gran cantidad de memoria, considera la posibilidad de llamar a [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante las fases de carga, como cuando se presenta una pantalla de carga o transición.</span><span class="sxs-lookup"><span data-stu-id="bf597-318">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="bf597-319">Agrupación de objetos</span><span class="sxs-lookup"><span data-stu-id="bf597-319">Object pooling</span></span>

<span data-ttu-id="bf597-320">La agrupación de objetos es una técnica popular para reducir el costo de asignaciones y anulaciones de asignación continuas de objetos.</span><span class="sxs-lookup"><span data-stu-id="bf597-320">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="bf597-321">Para ello, se asigna un grupo grande de objetos idénticos y se reutilizan instancias disponibles inactivas de este grupo en lugar de generar y destruir objetos constantemente a lo largo del tiempo.</span><span class="sxs-lookup"><span data-stu-id="bf597-321">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="bf597-322">Los grupos de objetos son excelentes para los componentes reutilizables que tienen una duración variable en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf597-322">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="bf597-323">Tutorial de agrupación de objetos en Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-323">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="bf597-324">Rendimiento del inicio</span><span class="sxs-lookup"><span data-stu-id="bf597-324">Startup performance</span></span>

<span data-ttu-id="bf597-325">Considera la posibilidad de iniciar la aplicación con una escena más pequeña y, a continuación, usar *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* para cargar el resto de la escena.</span><span class="sxs-lookup"><span data-stu-id="bf597-325">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="bf597-326">Esto permite a la aplicación acceder a un estado interactivo lo más rápido posible.</span><span class="sxs-lookup"><span data-stu-id="bf597-326">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="bf597-327">Ten en cuenta que puede haber un gran pico de CPU mientras se activa la nueva escena y que cualquier contenido representado se puede trabar o enganchar.</span><span class="sxs-lookup"><span data-stu-id="bf597-327">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="bf597-328">Una manera de solucionar este problema es establecer la propiedad AsyncOperation.allowSceneActivation en "false" en la escena que se está cargando, esperar a que se cargue, fundir a negro la pantalla y volver a establecerla en "true" para completar la activación de la escena.</span><span class="sxs-lookup"><span data-stu-id="bf597-328">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="bf597-329">Recuerda que mientras se carga la escena de inicio, se mostrará la pantalla de presentación holográfica al usuario.</span><span class="sxs-lookup"><span data-stu-id="bf597-329">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="bf597-330">Consulta también</span><span class="sxs-lookup"><span data-stu-id="bf597-330">See also</span></span>
- [<span data-ttu-id="bf597-331">Optimización de la representación de gráficos en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-331">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="bf597-332">Optimización de la recolección de elementos no utilizados en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="bf597-332">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="bf597-333">[Procedimientos recomendados para la física [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="bf597-333">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="bf597-334">[Optimización de scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="bf597-334">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
