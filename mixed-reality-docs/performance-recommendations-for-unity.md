---
title: Recomendaciones de rendimiento para Unity
description: Sugerencias específicas de Unity para mejorar el rendimiento con las aplicaciones de realidad mixta.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: gráficos, cpu, gpu, representación, recolección de elementos, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843333"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="e0edc-104">Recomendaciones de rendimiento para Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="e0edc-105">Este artículo se basa en la explicación que se describen en [recomendaciones de rendimiento para realidad mixta](understanding-performance-for-mixed-reality.md) pero se centra en aprendizajes específicas del entorno de motor de Unity.</span><span class="sxs-lookup"><span data-stu-id="e0edc-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="e0edc-106">También es aconsejable que los desarrolladores revisen el [recomienda la configuración del entorno para el artículo de Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="e0edc-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="e0edc-107">En este artículo tiene contenido con algunas de las configuraciones de escena más importante en lo que respecta a la creación de alto rendimiento de aplicaciones de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="e0edc-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="e0edc-108">También algunos de estos valores recomendados se resaltan a continuación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="e0edc-109">Cómo generar perfiles con Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-109">How to profile with Unity</span></span>

<span data-ttu-id="e0edc-110">Unity proporciona el **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** integrado que es un excelente recurso para recopilar información de rendimiento valiosas para la aplicación concreta.</span><span class="sxs-lookup"><span data-stu-id="e0edc-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="e0edc-111">Aunque puede ejecutar el generador de perfiles en el editor, estas métricas no representan el entorno en tiempo de ejecución es true y por lo tanto, los resultados de esta deben usarse con precaución.</span><span class="sxs-lookup"><span data-stu-id="e0edc-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="e0edc-112">Se recomienda para el perfil de forma remota su aplicación mientras se ejecuta en el dispositivo para obtener información más precisa y útil.</span><span class="sxs-lookup"><span data-stu-id="e0edc-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="e0edc-113">Además, Unity [depurador marco](https://docs.unity3d.com/Manual/FrameDebugger.html) también es muy eficaz y herramienta de información para usar.</span><span class="sxs-lookup"><span data-stu-id="e0edc-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="e0edc-114">Unity proporciona documentación excelente para:</span><span class="sxs-lookup"><span data-stu-id="e0edc-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="e0edc-115">Cómo conectar el [generador de perfiles de Unity para aplicaciones UWP remotamente](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="e0edc-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="e0edc-116">Cómo eficazmente [diagnosticar problemas de rendimiento con el Profiler de Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="e0edc-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="e0edc-117">Con el Profiler Unity conectado y después de agregar el generador de perfiles GPU (consulte *agregar Profiler* en la esquina superior derecha), puede ver cuánto tiempo se invierte en la CPU y GPU respectivamente en medio del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="e0edc-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="e0edc-118">Esto permite al desarrollador obtener una aproximación rápida si su aplicación es la CPU o GPU limitado.</span><span class="sxs-lookup"><span data-stu-id="e0edc-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![Vs para Unity CPU GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="e0edc-120">Recomendaciones de rendimiento de CPU</span><span class="sxs-lookup"><span data-stu-id="e0edc-120">CPU performance recommendations</span></span>

<span data-ttu-id="e0edc-121">El siguiente contenido trata más prácticas detalladas de rendimiento, especialmente destinadas a Unity & C# desarrollo.</span><span class="sxs-lookup"><span data-stu-id="e0edc-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="e0edc-122">Memoria caché las referencias</span><span class="sxs-lookup"><span data-stu-id="e0edc-122">Cache references</span></span>

<span data-ttu-id="e0edc-123">Es una práctica recomendada para las referencias a todos los componentes pertinentes y GameObjects en la inicialización.</span><span class="sxs-lookup"><span data-stu-id="e0edc-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="e0edc-124">Esto es porque las llamadas a funciones de repetición, como *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* es mucho más costoso en relación con el costo para almacenar un puntero de memoria.</span><span class="sxs-lookup"><span data-stu-id="e0edc-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="e0edc-125">Esto también se aplica a la muy, con frecuencia utilizan [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="e0edc-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="e0edc-126">*Camera.Main* realmente solo usa *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* debajo que busca costosa en el gráfico de escena para un objeto de cámara con la *"MainCamera"*  etiqueta.</span><span class="sxs-lookup"><span data-stu-id="e0edc-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="e0edc-127">Evitar GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="e0edc-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="e0edc-128">Cuando se usa  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , hay una serie de sobrecargas diferentes.</span><span class="sxs-lookup"><span data-stu-id="e0edc-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="e0edc-129">Es importante usar siempre las implementaciones en función del tipo y nunca la sobrecarga de búsqueda basada en cadena.</span><span class="sxs-lookup"><span data-stu-id="e0edc-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="e0edc-130">Búsqueda por la cadena de la escena es significativamente más costosa que la búsqueda por tipo.</span><span class="sxs-lookup"><span data-stu-id="e0edc-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="e0edc-131">(Bueno) Componente GetComponent (tipo)</span><span class="sxs-lookup"><span data-stu-id="e0edc-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="e0edc-132">(Bueno) T GetComponent\<T >)</span><span class="sxs-lookup"><span data-stu-id="e0edc-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="e0edc-133">(Incorrecto) Componente GetComponent(string) ></span><span class="sxs-lookup"><span data-stu-id="e0edc-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="e0edc-134">Evite operaciones caras</span><span class="sxs-lookup"><span data-stu-id="e0edc-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="e0edc-135">**Evite el uso de [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="e0edc-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="e0edc-136">Aunque LINQ puede ser muy limpia y fácil de leer y escribir, por lo general requiere cálculo mucho más y más especialmente la asignación de memoria que escribir manualmente el algoritmo de.</span><span class="sxs-lookup"><span data-stu-id="e0edc-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="e0edc-137">**API de Unity comunes**</span><span class="sxs-lookup"><span data-stu-id="e0edc-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="e0edc-138">Ciertas API de Unity, aunque es útil, puede ser muy costoso de ejecutar.</span><span class="sxs-lookup"><span data-stu-id="e0edc-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="e0edc-139">La mayoría de ellos implica buscar en el gráfico de escena completa para alguna lista de búsqueda de coincidencias de GameObjects.</span><span class="sxs-lookup"><span data-stu-id="e0edc-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="e0edc-140">Estas operaciones por lo general pueden evitarse mediante el almacenamiento en caché las referencias o implementar un componente de administrador para que los GameObjects en cuestión realizar el seguimiento de las referencias en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e0edc-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="e0edc-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  y *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* debe eliminarse a toda costa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="e0edc-142">Estas funciones pueden ser del orden de 1000 veces más lento que las llamadas de función directa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="e0edc-143">**Tenga cuidado con conversión boxing**</span><span class="sxs-lookup"><span data-stu-id="e0edc-143">**Beware of boxing**</span></span>

    <span data-ttu-id="e0edc-144">[Conversión boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) es un concepto básico de la C# lenguaje y tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e0edc-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="e0edc-145">Es el proceso de ajuste de las variables de tipo de valor como char, int, bool, etc. en las variables con tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e0edc-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="e0edc-146">Una variable de tipo de valor es "boxing", se encapsula dentro de una clase System.Object que se almacena en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="e0edc-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="e0edc-147">Por lo tanto, se asigna memoria y, finalmente, cuando se elimina debe ser procesada por el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="e0edc-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="e0edc-148">Estas asignaciones y desasignaciones incurrir en costos de rendimiento y en muchos escenarios no son necesarias o se pueden reemplazar fácilmente por una alternativa menos costosa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="e0edc-149">Repetición de las rutas de código</span><span class="sxs-lookup"><span data-stu-id="e0edc-149">Repeating code paths</span></span>

<span data-ttu-id="e0edc-150">Las funciones de devolución de llamada Unity repetición (como)</span><span class="sxs-lookup"><span data-stu-id="e0edc-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="e0edc-151">Actualización) que se ejecutan muchas veces por segundo o marco debe escribirse con mucho cuidado.</span><span class="sxs-lookup"><span data-stu-id="e0edc-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="e0edc-152">Operaciones costosas aquí tendrá impacto enorme y coherente en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="e0edc-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="e0edc-153">**Funciones de devolución de llamada vacío**</span><span class="sxs-lookup"><span data-stu-id="e0edc-153">**Empty callback functions**</span></span>

    <span data-ttu-id="e0edc-154">Aunque el código siguiente puede parecer inofensivo para dejar en su aplicación, especialmente porque cada script Unity auto-inicializa con este bloque de código, estas devoluciones de llamada vacíos pueden pasar a ser muy costosas.</span><span class="sxs-lookup"><span data-stu-id="e0edc-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="e0edc-155">Unity y viceversa funciona a través de un límite de código no administrado o administrado, entre el código de UnityEngine y el código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="e0edc-156">Cambio a través de este puente de contexto es bastante costoso, incluso si no hay nada que ejecutar.</span><span class="sxs-lookup"><span data-stu-id="e0edc-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="e0edc-157">Esto es especialmente problemático si la aplicación tiene cientos de GameObjects con los componentes que tienen las devoluciones de llamada de Unity repetición vacíos.</span><span class="sxs-lookup"><span data-stu-id="e0edc-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="e0edc-158">Update() es la manifestación más común de este problema de rendimiento, pero otras devoluciones de llamada de repetición Unity como la siguiente pueden ser igualmente tan malo si no peor: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="e0edc-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="e0edc-159">**Operaciones para favorecer la ejecución de una vez por fotograma**</span><span class="sxs-lookup"><span data-stu-id="e0edc-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="e0edc-160">Las siguientes API de Unity son operaciones comunes para muchas aplicaciones holográfica.</span><span class="sxs-lookup"><span data-stu-id="e0edc-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="e0edc-161">Aunque no siempre es posible, los resultados de estas funciones con mucha frecuencia se pueden calcular una vez y volver a utilizan los resultados a través de la aplicación de un período determinado.</span><span class="sxs-lookup"><span data-stu-id="e0edc-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="e0edc-162">(a) por lo general es recomendable tener una clase Singleton dedicado o un servicio para controlar a su mirada Raycast en la escena y, a continuación, volver a usar este resultado en todos los demás componentes de la escena, en lugar de realizar operaciones de Raycast repetidas y prácticamente idénticas por cada uno componente.</span><span class="sxs-lookup"><span data-stu-id="e0edc-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="e0edc-163">Por supuesto, algunas aplicaciones pueden requerir raycasts desde diferentes orígenes o en diferentes [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="e0edc-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="e0edc-164">(b) evitar GetComponent() operaciones repetidas devoluciones de llamada de Unity como Update() por [almacenamiento en caché las referencias](#cache-references) en Start() o Awake()</span><span class="sxs-lookup"><span data-stu-id="e0edc-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="e0edc-165">(c) es recomendable crear instancias de todos los objetos, si es posible, y use la inicialización [agrupación de objetos](#object-pooling) reciclar y volver a utilizar GameObjects a lo largo del tiempo de ejecución de la aplicación</span><span class="sxs-lookup"><span data-stu-id="e0edc-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="e0edc-166">**Evitar interfaces y construcciones virtuales**</span><span class="sxs-lookup"><span data-stu-id="e0edc-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="e0edc-167">Invocar llamadas a funciones a través de interfaces frente a direct objetos o llamar a funciones virtuales a veces puede consumir mucho más caros que utilizando construcciones directas o llamadas de función directa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="e0edc-168">Si la función virtual o la interfaz no es necesario, se debe quitar.</span><span class="sxs-lookup"><span data-stu-id="e0edc-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="e0edc-169">Sin embargo, el rendimiento de aciertos de estos enfoques son generalmente vale la pena el equilibrio si aprovechando simplifica la colaboración de desarrollo, la legibilidad del código y mantenimiento del código.</span><span class="sxs-lookup"><span data-stu-id="e0edc-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="e0edc-170">**Evitar las estructuras de pasar por valor**</span><span class="sxs-lookup"><span data-stu-id="e0edc-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="e0edc-171">A diferencia de las clases, structs son tipos de valor y cuando se pasa directamente a una función, su contenido se copia en una instancia recién creada.</span><span class="sxs-lookup"><span data-stu-id="e0edc-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="e0edc-172">Esta copia agrega, así como memoria adicional en la pila el costo de CPU.</span><span class="sxs-lookup"><span data-stu-id="e0edc-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="e0edc-173">Para los structs pequeño, el efecto es generalmente muy mínima y, por tanto, aceptable.</span><span class="sxs-lookup"><span data-stu-id="e0edc-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="e0edc-174">Sin embargo, para funciones invocan repetidamente cada fotograma, así como funciones que tardan las estructuras de gran tamaño, si es posible modificar la definición de función para pasar por referencia.</span><span class="sxs-lookup"><span data-stu-id="e0edc-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="e0edc-175">Obtenga más información aquí</span><span class="sxs-lookup"><span data-stu-id="e0edc-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="e0edc-176">Varios</span><span class="sxs-lookup"><span data-stu-id="e0edc-176">Miscellaneous</span></span>

1) <span data-ttu-id="e0edc-177">**Física**</span><span class="sxs-lookup"><span data-stu-id="e0edc-177">**Physics**</span></span>

    <span data-ttu-id="e0edc-178">(a) por lo general, la manera más fácil para mejorar la física es limitar la cantidad de tiempo invertido en física o el número de iteraciones por segundo.</span><span class="sxs-lookup"><span data-stu-id="e0edc-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="e0edc-179">Por supuesto, esto reducirá la precisión de la simulación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="e0edc-180">Consulte [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) en Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="e0edc-181">(b) el tipo de colisionadores en Unity tiene características de rendimiento muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="e0edc-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="e0edc-182">El orden siguiente enumera la mayoría colisionadores de alto rendimiento a menor colisionadores de alto rendimiento de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="e0edc-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="e0edc-183">Es más importante evitar Colisionadores de malla que son considerablemente más costoso que el primitivos colisionadores.</span><span class="sxs-lookup"><span data-stu-id="e0edc-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="e0edc-184">Consulte [prácticas recomendadas de Unity física](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) para obtener más información</span><span class="sxs-lookup"><span data-stu-id="e0edc-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="e0edc-185">**Animaciones**</span><span class="sxs-lookup"><span data-stu-id="e0edc-185">**Animations**</span></span>

    <span data-ttu-id="e0edc-186">Deshabilitar las animaciones inactivas al deshabilitar el componente de Animador (deshabilitar el objeto de juego tendrá el mismo efecto).</span><span class="sxs-lookup"><span data-stu-id="e0edc-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="e0edc-187">Evite los patrones de diseño donde se ubica una animación en un bucle que establecer un valor a la misma cosa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="e0edc-188">Hay una sobrecarga considerable para que esta técnica no tiene ningún efecto en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="e0edc-189">Obtenga más información aquí.</span><span class="sxs-lookup"><span data-stu-id="e0edc-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="e0edc-190">**Algoritmos complejos**</span><span class="sxs-lookup"><span data-stu-id="e0edc-190">**Complex algorithms**</span></span>

    <span data-ttu-id="e0edc-191">Si la aplicación utiliza algoritmos complejos como cinemática inversa, búsqueda de ruta de acceso, etcetera, buscar para buscar un enfoque más sencillo o ajustar la configuración pertinente de su rendimiento</span><span class="sxs-lookup"><span data-stu-id="e0edc-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="e0edc-192">Recomendaciones de rendimiento de la CPU al GPU</span><span class="sxs-lookup"><span data-stu-id="e0edc-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="e0edc-193">Por lo general, el rendimiento de CPU al GPU viene abajo hasta la **llamadas a draw** enviadas a la tarjeta gráfica.</span><span class="sxs-lookup"><span data-stu-id="e0edc-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="e0edc-194">Para mejorar el rendimiento, las llamadas a draw deben ser estratégicamente **) reduce** o **b) reestructurado** para obtener resultados óptimos.</span><span class="sxs-lookup"><span data-stu-id="e0edc-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="e0edc-195">Puesto que las llamadas de dibujo a sí mismos son intensivo de recursos, lo que reduce su reducirá trabajo general necesario.</span><span class="sxs-lookup"><span data-stu-id="e0edc-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="e0edc-196">Además, los cambios entre las llamadas a draw requiere validación costoso y los pasos de traducción en el controlador de gráficos de estado y por lo tanto, se reestructurarán las llamadas a draw de la aplicación para limitar los cambios de estado (como)</span><span class="sxs-lookup"><span data-stu-id="e0edc-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="e0edc-197">materiales diferentes, etcetera) puede mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="e0edc-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="e0edc-198">Unity ofrece un excelente artículo que ofrece información general y profundiza en llamadas a draw para su plataforma de procesamiento por lotes.</span><span class="sxs-lookup"><span data-stu-id="e0edc-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="e0edc-199">Unity dibujar llamada procesamiento por lotes</span><span class="sxs-lookup"><span data-stu-id="e0edc-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="e0edc-200">Representación con instancias de paso único</span><span class="sxs-lookup"><span data-stu-id="e0edc-200">Single pass instanced rendering</span></span>

<span data-ttu-id="e0edc-201">Representación de un solo paso Instanced en Unity permite llamadas a draw para todos los ojos a reducirse hasta la llamada a draw con instancias uno.</span><span class="sxs-lookup"><span data-stu-id="e0edc-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="e0edc-202">Debido a la coherencia entre las dos llamadas de dibujo de la caché, también hay ciertas mejoras de rendimiento en la GPU también.</span><span class="sxs-lookup"><span data-stu-id="e0edc-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="e0edc-203">Para habilitar esta característica en el proyecto de Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="e0edc-204">Abra **configuración del Reproductor XR** (vaya a **editar** > **configuración del proyecto** > **Reproductor**  >  **Configuración XR**)</span><span class="sxs-lookup"><span data-stu-id="e0edc-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="e0edc-205">Seleccione **pasar una instancia única** desde el **el método de representación estéreo** menú desplegable (**admite la realidad Virtual** casilla debe estar seleccionada)</span><span class="sxs-lookup"><span data-stu-id="e0edc-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="e0edc-206">Lea los artículos siguientes de Unity para obtener más información con este enfoque de representación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="e0edc-207">Cómo maximizar el rendimiento de AR y VR con representación estéreo avanzada</span><span class="sxs-lookup"><span data-stu-id="e0edc-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="e0edc-208">Creación de instancias de un solo paso</span><span class="sxs-lookup"><span data-stu-id="e0edc-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="e0edc-209">Se produce un problema común con solo pasar una instancia de representación si los desarrolladores ya tienen sombreadores personalizados existentes no escritos para creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="e0edc-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="e0edc-210">Después de habilitar esta característica, los desarrolladores que observe algún procesamiento solo GameObjects en un ojo.</span><span class="sxs-lookup"><span data-stu-id="e0edc-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="e0edc-211">Esto es porque los sombreadores personalizados asociados no tienen las propiedades adecuadas para la creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="e0edc-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="e0edc-212">Consulte [solo pasar estéreo de representación de HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) desde Unity para abordar este problema</span><span class="sxs-lookup"><span data-stu-id="e0edc-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="e0edc-213">El procesamiento por lotes estático</span><span class="sxs-lookup"><span data-stu-id="e0edc-213">Static batching</span></span>

<span data-ttu-id="e0edc-214">Unity es capaz de procesar por lotes demasiados objetos static para reducir las llamadas de dibujo a la GPU.</span><span class="sxs-lookup"><span data-stu-id="e0edc-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="e0edc-215">El procesamiento por lotes estática funciona para la mayoría [representador](https://docs.unity3d.com/ScriptReference/Renderer.html) objetos de Unity que **(1) comparten el mismo material de** y **2) son todas marcadas como *estático***  () Seleccione un objeto en Unity y haga clic en la casilla de verificación en la parte superior derecha del inspector de).</span><span class="sxs-lookup"><span data-stu-id="e0edc-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="e0edc-216">GameObjects marcado como *estático* no se puede mover a lo largo del tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="e0edc-217">Por lo tanto, puede ser difícil aprovechar en HoloLens donde debe colocarse, mover, escala, etcetera prácticamente todos los objetos estáticos de procesamiento por lotes. Para inmersivos, los estáticos de procesamiento por lotes puede reducir drásticamente las llamadas a draw y, por tanto, mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="e0edc-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="e0edc-218">Lectura *estático de procesamiento por lotes* en [dibujar llame al procesamiento por lotes en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="e0edc-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="e0edc-219">El procesamiento por lotes dinámico</span><span class="sxs-lookup"><span data-stu-id="e0edc-219">Dynamic batching</span></span>

<span data-ttu-id="e0edc-220">Puesto que es problemático para marcar objetos como *estático* para el desarrollo de HoloLens, el procesamiento por lotes dinámico puede ser una excelente herramienta para compensarlo que carecen de característica.</span><span class="sxs-lookup"><span data-stu-id="e0edc-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="e0edc-221">Por supuesto, es puede también resultar útil en inmersivos también.</span><span class="sxs-lookup"><span data-stu-id="e0edc-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="e0edc-222">Dinámica de procesamiento por lotes en Unity puede ser difícil Aunque habilitar porque debe GameObjects **) compartir el mismo Material** y **b) cumplir con una larga lista de otros criterios**.</span><span class="sxs-lookup"><span data-stu-id="e0edc-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="e0edc-223">Lectura *dinámica de procesamiento por lotes* en [dibujar llame al procesamiento por lotes en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para ver la lista completa.</span><span class="sxs-lookup"><span data-stu-id="e0edc-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="e0edc-224">Normalmente, GameObjects dejan de ser válidos para procesar por lotes dinámicamente porque los datos de la malla asociado pueden ser no más de 300 vértices.</span><span class="sxs-lookup"><span data-stu-id="e0edc-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="e0edc-225">otras técnicas</span><span class="sxs-lookup"><span data-stu-id="e0edc-225">Other techniques</span></span>

<span data-ttu-id="e0edc-226">Procesamiento por lotes sólo puede ocurrir si se pueden compartir el mismo material de varias GameObjects.</span><span class="sxs-lookup"><span data-stu-id="e0edc-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="e0edc-227">Normalmente esto bloqueará la necesidad de GameObjects disponer de una textura única para su respectivo Material.</span><span class="sxs-lookup"><span data-stu-id="e0edc-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="e0edc-228">Es habitual combinar las texturas en una textura grande, un método conocido como [Atlasing textura](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="e0edc-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="e0edc-229">Además, es preferible generalmente para combinar las mallas en un GameObject donde sea posible y razonable.</span><span class="sxs-lookup"><span data-stu-id="e0edc-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="e0edc-230">Cada representador en Unity hará que se ha asociado las llamadas de dibujo frente al envío de una malla combinada en un representador.</span><span class="sxs-lookup"><span data-stu-id="e0edc-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="e0edc-231">Modificar las propiedades de Renderer.material en tiempo de ejecución creará una copia del Material y, por tanto, afectar el procesamiento por lotes.</span><span class="sxs-lookup"><span data-stu-id="e0edc-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="e0edc-232">Utilice Renderer.sharedMaterial para modificar las propiedades de material compartidas entre GameObjects.</span><span class="sxs-lookup"><span data-stu-id="e0edc-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="e0edc-233">Recomendaciones de rendimiento de GPU</span><span class="sxs-lookup"><span data-stu-id="e0edc-233">GPU performance recommendations</span></span>

<span data-ttu-id="e0edc-234">Obtenga más información sobre [optimización de la representación de gráficos en Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="e0edc-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span> 

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="e0edc-235">Optimizar el uso compartido de búfer de profundidad</span><span class="sxs-lookup"><span data-stu-id="e0edc-235">Optimize depth buffer sharing</span></span>

<span data-ttu-id="e0edc-236">Por lo general se recomienda habilitar **uso compartido de búfer de profundidad** en **configuración del Reproductor XR** para optimizar el [estabilidad holograma](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="e0edc-236">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="e0edc-237">Cuando se habilita en función de profundidad de la etapa tardía reprojection con esta configuración no obstante, se recomienda seleccionar **formato profundidad de 16 bits** en lugar de **formato de 24 bits profundidad**.</span><span class="sxs-lookup"><span data-stu-id="e0edc-237">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="e0edc-238">Usará los búferes de profundidad de 16 bits reduce drásticamente el ancho de banda (y, por tanto, de energía) asociado con el tráfico de búfer de profundidad.</span><span class="sxs-lookup"><span data-stu-id="e0edc-238">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="e0edc-239">Esto puede ser una ventaja de gran potencia, pero solo es aplicable para las experiencias con un intervalo de profundidad pequeña como [luchas z](https://en.wikipedia.org/wiki/Z-fighting) es más probable que ocurra con 16 bits a 24 bits.</span><span class="sxs-lookup"><span data-stu-id="e0edc-239">This can be a big power win, but is only applicable for experiences with a small depth range as [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) is more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="e0edc-240">Para evitar estos artefactos, modifique los planos de recorte cerca o lejos de la [cámara Unity](https://docs.unity3d.com/Manual/class-Camera.html) para tener en cuenta la precisión inferior.</span><span class="sxs-lookup"><span data-stu-id="e0edc-240">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="e0edc-241">Para las aplicaciones basadas en HoloLens, un plano de recorte lejano de 50 millones en lugar del predeterminado de Unity 1000 m generalmente puede eliminar cualquier luchas z.</span><span class="sxs-lookup"><span data-stu-id="e0edc-241">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="e0edc-242">Reducir el número de poli</span><span class="sxs-lookup"><span data-stu-id="e0edc-242">Reduce poly count</span></span>

<span data-ttu-id="e0edc-243">Normalmente se reduce el número de polígonos, ya sea por</span><span class="sxs-lookup"><span data-stu-id="e0edc-243">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="e0edc-244">Quitar objetos de una escena</span><span class="sxs-lookup"><span data-stu-id="e0edc-244">Removing objects from a scene</span></span>
2) <span data-ttu-id="e0edc-245">Diezmado activos lo que reduce el número de polígonos de una malla determinada</span><span class="sxs-lookup"><span data-stu-id="e0edc-245">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="e0edc-246">Implementar un [System de nivel de detalle (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) en la aplicación que procesa lejos estén los objetos con la versión de polígono de inferior de la misma geometría</span><span class="sxs-lookup"><span data-stu-id="e0edc-246">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="e0edc-247">Sombreadores de descripción en Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-247">Understanding shaders in Unity</span></span>

<span data-ttu-id="e0edc-248">Una sencilla aproximación para comparar a los sombreadores en el rendimiento es identificar el número promedio de operaciones cada que se ejecuta en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e0edc-248">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="e0edc-249">Esto puede hacerse fácilmente en Unity.</span><span class="sxs-lookup"><span data-stu-id="e0edc-249">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="e0edc-250">Seleccione el recurso de sombreador o seleccione un material, en la esquina superior derecha de la ventana del inspector, seleccione el icono de engranaje y, a continuación, **"Seleccione sombreador"**</span><span class="sxs-lookup"><span data-stu-id="e0edc-250">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Seleccione el sombreador de Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="e0edc-252">Con el recurso de sombreador seleccionado, haga clic en el **"Compilar y mostrar el código"** botón en la ventana del inspector</span><span class="sxs-lookup"><span data-stu-id="e0edc-252">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilar el código del sombreador de Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="e0edc-254">Después de compilar, busque la sección de estadísticas en los resultados con el número de operaciones diferentes para el sombreador de píxeles y vértices (Nota: los sombreadores de píxeles se denominan a menudo también los sombreadores de fragmento)</span><span class="sxs-lookup"><span data-stu-id="e0edc-254">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operaciones estándar de sombreador de Unity](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="e0edc-256">Sombreadores de píxeles de optimización</span><span class="sxs-lookup"><span data-stu-id="e0edc-256">Optmize pixel shaders</span></span>

<span data-ttu-id="e0edc-257">Examina los resultados de la estadística compilados utilizando el método anterior, el [fragmento sombreador](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) generalmente se ejecutarán más operaciones que el [sombreador de vértices](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) por término medio.</span><span class="sxs-lookup"><span data-stu-id="e0edc-257">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="e0edc-258">Se ejecuta el sombreador de fragmentos, también conocido como el sombreador de píxeles por píxel en la pantalla mientras el sombreador de vértices es sólo ejecutada por vértice de todas las mallas se dibuja en la pantalla de salida.</span><span class="sxs-lookup"><span data-stu-id="e0edc-258">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="e0edc-259">Por lo tanto, no sólo los sombreadores de fragmento es necesario obtener más instrucciones aparte de los sombreadores de vértices debido a todos los cálculos de iluminación, sombreadores fragmento casi siempre se ejecutan en un conjunto de datos mayor.</span><span class="sxs-lookup"><span data-stu-id="e0edc-259">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="e0edc-260">Por ejemplo, si la salida de pantalla es de 2k por imagen de 2 k, a continuación, puede obtener el sombreador de fragmento ejecuta 2 000 \* 2, 4,000,000 = 000 veces.</span><span class="sxs-lookup"><span data-stu-id="e0edc-260">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="e0edc-261">Si la representación de dos ojos, este número se duplica puesto que hay dos pantallas.</span><span class="sxs-lookup"><span data-stu-id="e0edc-261">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="e0edc-262">Si una aplicación de realidad mixta tiene varias pasadas, pantalla completa posprocesamiento efectos o representar varias mallas al mismo píxel, este número aumentará drásticamente.</span><span class="sxs-lookup"><span data-stu-id="e0edc-262">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="e0edc-263">Por lo tanto, lo que reduce el número de operaciones en el sombreador de fragmento puede generalmente proporcionan mucho mayores mejoras de rendimiento a través de las optimizaciones del sombreador de vértices.</span><span class="sxs-lookup"><span data-stu-id="e0edc-263">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="e0edc-264">Alternativas de estándar de sombreador de Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-264">Unity Standard shader alternatives</span></span>

<span data-ttu-id="e0edc-265">En lugar de una representación basada en físicamente (PBR) u otro sombreador de alta calidad, examine el uso de un mayor rendimiento y el sombreador más barato.</span><span class="sxs-lookup"><span data-stu-id="e0edc-265">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="e0edc-266">El [Kit de herramientas de realidad mixta](https://github.com/Microsoft/MixedRealityToolkit-Unity) proporciona el [sombreador estándar MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) que se ha optimizado para los proyectos de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="e0edc-266">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="e0edc-267">Unity también proporciona un apagado, vértice iluminado, sombras simplificada difuso y otras opciones que son significativamente más rápido si se compara con el sombreador de Unity estándar.</span><span class="sxs-lookup"><span data-stu-id="e0edc-267">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="e0edc-268">Consulte [uso y rendimiento de sombreadores integrados](https://docs.unity3d.com/Manual/shader-Performance.html) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="e0edc-268">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="e0edc-269">Carga previa del sombreador</span><span class="sxs-lookup"><span data-stu-id="e0edc-269">Shader preloading</span></span>

<span data-ttu-id="e0edc-270">Use *sombreador precargar* y otros trucos para optimizar [tiempo de carga de sombreador](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="e0edc-270">Use *Shader preloading* and other tricks to optimize [shader load time](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="e0edc-271">En concreto, la carga previa del sombreador significa, no verá las complicaciones debido a la compilación del sombreador en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e0edc-271">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="e0edc-272">Límite de sobredibujo</span><span class="sxs-lookup"><span data-stu-id="e0edc-272">Limit overdraw</span></span>

<span data-ttu-id="e0edc-273">En Unity, uno puede mostrar el sobredibujo para su escena, alternando el [ **dibujar menú modo de** ](https://docs.unity3d.com/Manual/ViewModes.html) en la esquina superior izquierda de la **vista de escena** y seleccionando **Sobredibujo** .</span><span class="sxs-lookup"><span data-stu-id="e0edc-273">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="e0edc-274">Por lo general, el sobredibujo se puede mitigar mediante el sacrificio de objetos antes de tiempo antes de enviarlos a la GPU.</span><span class="sxs-lookup"><span data-stu-id="e0edc-274">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="e0edc-275">Unity proporciona detalles sobre cómo implementar [oclusión de caras traseras](https://docs.unity3d.com/Manual/OcclusionCulling.html) para su motor.</span><span class="sxs-lookup"><span data-stu-id="e0edc-275">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="e0edc-276">Recomendaciones de memoria</span><span class="sxs-lookup"><span data-stu-id="e0edc-276">Memory recommendations</span></span>

<span data-ttu-id="e0edc-277">Las operaciones de asignación y desasignación de memoria excesivo pueden tener efectos adversos sobre su aplicación holográfica, dando como resultado un rendimiento incoherente, marcos inmovilizados y otro comportamiento perjudicial.</span><span class="sxs-lookup"><span data-stu-id="e0edc-277">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="e0edc-278">Es especialmente importante entender las consideraciones de memoria al desarrollar en Unity, puesto que la administración de memoria se controla mediante el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="e0edc-278">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="e0edc-279">Recolección de elementos</span><span class="sxs-lookup"><span data-stu-id="e0edc-279">Garbage collection</span></span>

<span data-ttu-id="e0edc-280">Aplicaciones holográficas perderá el tiempo de proceso de procesamiento para el recolector de elementos no utilizados (GC) cuando se activa el GC para analizar los objetos que ya no están en ámbito durante la ejecución y su memoria debe liberarse por lo que puede hacer disponible para su reutilización.</span><span class="sxs-lookup"><span data-stu-id="e0edc-280">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="e0edc-281">Desasignación y asignaciones de constantes por lo general requerirá el recolector de elementos ejecutar con más frecuencia negativa, por tanto, rendimiento y experiencia del usuario.</span><span class="sxs-lookup"><span data-stu-id="e0edc-281">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="e0edc-282">Unity ha proporcionado una página excelente que se explica en detalle cómo funciona el recolector de elementos no utilizados y sugerencias para escribir código más eficaz en lo que respecta a la administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="e0edc-282">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="e0edc-283">Optimizar la recolección de elementos no utilizados en los juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-283">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="e0edc-284">Una de las prácticas más comunes que conduce a una excesiva recolección no almacena en caché las referencias a componentes y las clases en el desarrollo de Unity.</span><span class="sxs-lookup"><span data-stu-id="e0edc-284">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="e0edc-285">Deben ser capturadas durante Start() o Awake() y volver a usar en funciones más adelante como Update() o LateUpdate() todas las referencias.</span><span class="sxs-lookup"><span data-stu-id="e0edc-285">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="e0edc-286">Otras sugerencias rápidas:</span><span class="sxs-lookup"><span data-stu-id="e0edc-286">Other quick tips:</span></span>
- <span data-ttu-id="e0edc-287">Use la [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# clase para generar dinámicamente cadenas complejas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="e0edc-287">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="e0edc-288">Quite las llamadas a Debug.Log() cuando ya no necesite mientras se ejecutan todavía en todas las versiones de compilación de una aplicación</span><span class="sxs-lookup"><span data-stu-id="e0edc-288">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="e0edc-289">Si su aplicación holográfica generalmente requiere una gran cantidad de memoria, considere la posibilidad de llamar a [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante las fases de carga, como cuando se presenta una carga o pantalla de transición</span><span class="sxs-lookup"><span data-stu-id="e0edc-289">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="e0edc-290">Agrupación de objetos</span><span class="sxs-lookup"><span data-stu-id="e0edc-290">Object pooling</span></span>

<span data-ttu-id="e0edc-291">Agrupación de objetos es una técnica popular para reducir el costo de las asignaciones continua y las cancelaciones de asignación de objetos.</span><span class="sxs-lookup"><span data-stu-id="e0edc-291">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="e0edc-292">Esto se hace mediante la asignación de un grupo grande de objetos idénticos y volver a usar las instancias inactivas, disponibles desde este grupo en lugar de generar constantemente y destruir objetos con el tiempo.</span><span class="sxs-lookup"><span data-stu-id="e0edc-292">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="e0edc-293">Los grupos de objetos son excelentes para los componentes puedan volver a utilizar con duración de la variable durante una aplicación.</span><span class="sxs-lookup"><span data-stu-id="e0edc-293">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="e0edc-294">Tutorial de Unity de agrupación de objetos</span><span class="sxs-lookup"><span data-stu-id="e0edc-294">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="e0edc-295">Rendimiento de inicio</span><span class="sxs-lookup"><span data-stu-id="e0edc-295">Startup performance</span></span>

<span data-ttu-id="e0edc-296">Puede iniciar la aplicación con una escena más pequeña, a continuación, usar *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* para cargar el resto de la escena.</span><span class="sxs-lookup"><span data-stu-id="e0edc-296">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="e0edc-297">Esto permite que la aplicación llegar a un estado interactivo tan rápido como sea posible.</span><span class="sxs-lookup"><span data-stu-id="e0edc-297">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="e0edc-298">Se puede tener en cuenta que puede haber un gran aumento de CPU mientras se está activando la nueva escena y que cualquier contenido representado es posible que sufra interrupciones o problemas.</span><span class="sxs-lookup"><span data-stu-id="e0edc-298">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="e0edc-299">Una manera de solucionar este problema consiste en establecer la propiedad AsyncOperation.allowSceneActivation en false en la escena que se está cargando, espere a que la escena para cargar, desactive la pantalla en negro y, a continuación, vuelve a establecer en true para completar la activación de la escena.</span><span class="sxs-lookup"><span data-stu-id="e0edc-299">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="e0edc-300">Recuerde que, mientras se está cargando la escena de inicio se mostrará la pantalla de presentación holográfica al usuario.</span><span class="sxs-lookup"><span data-stu-id="e0edc-300">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="e0edc-301">Vea también</span><span class="sxs-lookup"><span data-stu-id="e0edc-301">See also</span></span>
- [<span data-ttu-id="e0edc-302">Optimización de la representación de gráficos de juegos Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-302">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="e0edc-303">Optimizar la recolección de elementos no utilizados en los juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="e0edc-303">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="e0edc-304">[Prácticas recomendadas de leyes físicas [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="e0edc-304">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="e0edc-305">[Optimización de las secuencias de comandos [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="e0edc-305">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
