---
title: Recomendaciones de rendimiento para Unity
description: Sugerencias específicas de Unity para mejorar el rendimiento con aplicaciones de realidad mixta.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: gráficos, CPU, GPU, representación, recolección de elementos no utilizados, hololens
ms.openlocfilehash: 6507667904cfa26dfad1ccf1402cc75f14386609
ms.sourcegitcommit: 9005b3fdfa87ac8fdc18a594a681e25c00ac5ce1
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/11/2019
ms.locfileid: "75003204"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="086f6-104">Recomendaciones de rendimiento para Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="086f6-105">Este artículo se basa en la explicación que se describe en [recomendaciones de rendimiento para la realidad mixta](understanding-performance-for-mixed-reality.md) pero se centra en los aprendizajes específicos del entorno del motor de Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="086f6-106">También es muy recomendable que los desarrolladores revisen el [artículo de configuración de entorno recomendado para Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="086f6-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="086f6-107">En este artículo se incluye contenido con algunas de las configuraciones de escenas más importantes para la creación de aplicaciones de realidad mixta de gran rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-107">This article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="086f6-108">Algunos de estos valores recomendados se resaltan a continuación.</span><span class="sxs-lookup"><span data-stu-id="086f6-108">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="086f6-109">Cómo generar perfiles con Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-109">How to profile with Unity</span></span>

<span data-ttu-id="086f6-110">Unity proporciona el **[generador de perfiles de Unity](https://docs.unity3d.com/Manual/Profiler.html)** integrado, que es un excelente recurso para recopilar información valiosa sobre el rendimiento de la aplicación en particular.</span><span class="sxs-lookup"><span data-stu-id="086f6-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="086f6-111">Aunque se puede ejecutar el generador de perfiles en el editor, estas métricas no representan el entorno en tiempo de ejecución real y, por tanto, se deben usar con precaución.</span><span class="sxs-lookup"><span data-stu-id="086f6-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="086f6-112">Se recomienda generar perfiles de forma remota de la aplicación mientras se ejecuta en el dispositivo para obtener información más precisa y útil.</span><span class="sxs-lookup"><span data-stu-id="086f6-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="086f6-113">Además, el [depurador de fotogramas](https://docs.unity3d.com/Manual/FrameDebugger.html) de Unity también es una herramienta muy eficaz y de información para su uso.</span><span class="sxs-lookup"><span data-stu-id="086f6-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="086f6-114">Unity proporciona una excelente documentación para:</span><span class="sxs-lookup"><span data-stu-id="086f6-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="086f6-115">Cómo conectar el [generador de perfiles de Unity a aplicaciones de UWP de forma remota](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="086f6-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="086f6-116">Cómo diagnosticar de forma eficaz [los problemas de rendimiento con el generador de perfiles de Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="086f6-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="086f6-117">Con el generador de perfiles de Unity conectado y después de agregar el generador de perfiles de GPU (consulte *Agregar Profiler* en la esquina superior derecha), puede ver cuánto tiempo se dedica a la CPU & GPU, respectivamente, en medio del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="086f6-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="086f6-118">Esto permite al desarrollador obtener una aproximación rápida si su aplicación está limitada por CPU o GPU.</span><span class="sxs-lookup"><span data-stu-id="086f6-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU de Unity frente a GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="086f6-120">Recomendaciones de rendimiento de CPU</span><span class="sxs-lookup"><span data-stu-id="086f6-120">CPU performance recommendations</span></span>

<span data-ttu-id="086f6-121">El contenido que aparece a continuación abarca prácticas más detalladas de rendimiento, especialmente destinadas a desarrollo de Unity & C# .</span><span class="sxs-lookup"><span data-stu-id="086f6-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="086f6-122">Referencias de caché</span><span class="sxs-lookup"><span data-stu-id="086f6-122">Cache references</span></span>

<span data-ttu-id="086f6-123">Se recomienda almacenar en caché las referencias a todos los componentes relevantes y GameObjects en la inicialización.</span><span class="sxs-lookup"><span data-stu-id="086f6-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="086f6-124">Esto se debe a que la repetición de llamadas de función como *[GetComponent\<t > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* son significativamente más caras en relación con el costo de memoria para almacenar un puntero.</span><span class="sxs-lookup"><span data-stu-id="086f6-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="086f6-125">Esto también se aplica a la [cámara. Main](https://docs.unity3d.com/ScriptReference/Camera-main.html)de uso frecuente.</span><span class="sxs-lookup"><span data-stu-id="086f6-125">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="086f6-126">En realidad, *Camera. Main* solo usa *[FindGameObjectsWithTag ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* , que busca de un modo costoso un objeto de cámara con la etiqueta *"MainCamera"* .</span><span class="sxs-lookup"><span data-stu-id="086f6-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="086f6-127">Evite GetComponent (cadena)</span><span class="sxs-lookup"><span data-stu-id="086f6-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="086f6-128">Al usar *[GetComponent ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , hay una serie de sobrecargas diferentes.</span><span class="sxs-lookup"><span data-stu-id="086f6-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="086f6-129">Es importante usar siempre las implementaciones basadas en tipos y nunca la sobrecarga de búsqueda basada en cadenas.</span><span class="sxs-lookup"><span data-stu-id="086f6-129">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="086f6-130">La búsqueda por cadena en la escena es significativamente más costosa que la búsqueda por tipo.</span><span class="sxs-lookup"><span data-stu-id="086f6-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="086f6-131">Apropiado Componente GetComponent (tipo Type)</span><span class="sxs-lookup"><span data-stu-id="086f6-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="086f6-132">Apropiado > T GetComponent\<T ()</span><span class="sxs-lookup"><span data-stu-id="086f6-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="086f6-133">N Componente GetComponent (cadena) ></span><span class="sxs-lookup"><span data-stu-id="086f6-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="086f6-134">Evite operaciones costosas</span><span class="sxs-lookup"><span data-stu-id="086f6-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="086f6-135">**Evitar el uso de [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="086f6-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="086f6-136">Aunque LINQ puede ser muy limpio y fácil de leer y escribir, generalmente requiere mucho más cálculo y más asignación de memoria que escribir el algoritmo de forma manual.</span><span class="sxs-lookup"><span data-stu-id="086f6-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="086f6-137">**API de Unity comunes**</span><span class="sxs-lookup"><span data-stu-id="086f6-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="086f6-138">Ciertas API de Unity, aunque resultan útiles, pueden ser muy costosas de ejecutar.</span><span class="sxs-lookup"><span data-stu-id="086f6-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="086f6-139">La mayoría de ellas implican buscar en todo el gráfico de escenas una lista coincidente de GameObjects.</span><span class="sxs-lookup"><span data-stu-id="086f6-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="086f6-140">Por lo general, estas operaciones se pueden evitar mediante el almacenamiento en caché de las referencias o la implementación de un componente de administrador para el GameObjects en cuestión para realizar el seguimiento de las referencias en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="086f6-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="086f6-141">*[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* y *[BroadcastMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* deben eliminarse a todos los costos.</span><span class="sxs-lookup"><span data-stu-id="086f6-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="086f6-142">Estas funciones pueden estar en el orden de 1000 veces más lento que las llamadas de función directas.</span><span class="sxs-lookup"><span data-stu-id="086f6-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="086f6-143">**Tenga cuidado con la conversión boxing**</span><span class="sxs-lookup"><span data-stu-id="086f6-143">**Beware of boxing**</span></span>

    <span data-ttu-id="086f6-144">La C# [conversión boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) es un concepto básico del lenguaje y del tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="086f6-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="086f6-145">Es el proceso de ajustar variables con tipo de valor como Char, int, bool, etc. en variables de tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="086f6-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="086f6-146">Cuando una variable con tipo de valor se "aplica a la conversión boxing", se ajusta dentro de un objeto System. Object que se almacena en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="086f6-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="086f6-147">Por lo tanto, se asigna la memoria y, en el momento en el que se elimina, debe ser procesada por el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="086f6-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="086f6-148">Estas asignaciones y desasignaciones incurren en un costo de rendimiento y en muchos escenarios no son necesarios o se pueden reemplazar fácilmente por una alternativa menos costosa.</span><span class="sxs-lookup"><span data-stu-id="086f6-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="086f6-149">Una de las formas más comunes de conversión boxing en el desarrollo es el uso de [tipos de valor que aceptan valores NULL](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="086f6-149">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="086f6-150">Es habitual tener la posibilidad de devolver null para un tipo de valor en una función, sobre todo cuando la operación puede producir un error al intentar obtener el valor.</span><span class="sxs-lookup"><span data-stu-id="086f6-150">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="086f6-151">El posible problema con este enfoque es que la asignación se produce ahora en el montón y, por consiguiente, debe ser recolectada como elemento no utilizado más adelante.</span><span class="sxs-lookup"><span data-stu-id="086f6-151">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="086f6-152">**Ejemplo de conversión boxing enC#**</span><span class="sxs-lookup"><span data-stu-id="086f6-152">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="086f6-153">**Ejemplo de conversión boxing problemática a través de tipos de valor que aceptan valores NULL**</span><span class="sxs-lookup"><span data-stu-id="086f6-153">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="086f6-154">Este código muestra una clase de partícula ficticia que se puede crear en un proyecto de Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-154">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="086f6-155">Una llamada a `TryGetSpeed()` producirá la asignación de objetos en el montón que necesitará recolectar elementos no utilizados en un momento posterior.</span><span class="sxs-lookup"><span data-stu-id="086f6-155">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="086f6-156">Este ejemplo es especialmente problemático, ya que puede haber 1000 o más partículas en una escena, cada una de las cuales solicita su velocidad actual.</span><span class="sxs-lookup"><span data-stu-id="086f6-156">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="086f6-157">Por lo tanto, se asignarán 1000 objetos y, por tanto, se anulará la asignación de cada fotograma, lo que reduciría considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-157">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="086f6-158">Volver a escribir la función para devolver un valor negativo como-1 para indicar un error evitaría este problema y mantener la memoria en la pila.</span><span class="sxs-lookup"><span data-stu-id="086f6-158">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="086f6-159">Repetir rutas de código</span><span class="sxs-lookup"><span data-stu-id="086f6-159">Repeating code paths</span></span>

<span data-ttu-id="086f6-160">Cualquier función de devolución de llamada de Unity repetida (es decir,</span><span class="sxs-lookup"><span data-stu-id="086f6-160">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="086f6-161">Update) que se ejecutan muchas veces por segundo o el marco debe escribirse con sumo cuidado.</span><span class="sxs-lookup"><span data-stu-id="086f6-161">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="086f6-162">Cualquier operación costosa aquí tendrá un impacto enorme y coherente en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-162">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="086f6-163">**Funciones de devolución de llamada vacías**</span><span class="sxs-lookup"><span data-stu-id="086f6-163">**Empty callback functions**</span></span>

    <span data-ttu-id="086f6-164">Aunque el código siguiente puede parecer inocentes de dejar en la aplicación, sobre todo porque cada script de Unity se inicializa automáticamente con este bloque de código, estas devoluciones de llamada vacías pueden llegar a ser muy costosas.</span><span class="sxs-lookup"><span data-stu-id="086f6-164">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="086f6-165">Unity opera hacia atrás y hacia delante a través de un límite de código administrado o no administrado, entre el código UnityEngine y el código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-165">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="086f6-166">El cambio de contexto sobre este puente es bastante caro, incluso si no hay nada que ejecutar.</span><span class="sxs-lookup"><span data-stu-id="086f6-166">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="086f6-167">Esto resulta especialmente problemático si la aplicación tiene 100 de GameObjects con componentes que tienen devoluciones de llamada de Unity repetidas.</span><span class="sxs-lookup"><span data-stu-id="086f6-167">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="086f6-168">Update () es la manifestación más común de este problema de rendimiento, pero otras devoluciones de llamada de Unity repetidas, como las siguientes pueden ser igualmente incorrectas, si no peor: FixedUpdate (), LateUpdate (), OnPostRender ", OnPreRender (), OnRenderImage (), etc.</span><span class="sxs-lookup"><span data-stu-id="086f6-168">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="086f6-169">**Operaciones para favorecer la ejecución una vez por fotograma**</span><span class="sxs-lookup"><span data-stu-id="086f6-169">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="086f6-170">Las siguientes API de Unity son operaciones comunes para muchas aplicaciones holográficas.</span><span class="sxs-lookup"><span data-stu-id="086f6-170">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="086f6-171">Aunque no siempre es posible, los resultados de estas funciones se suelen calcular una vez y los resultados se reutilizan en la aplicación para un fotograma determinado.</span><span class="sxs-lookup"><span data-stu-id="086f6-171">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="086f6-172">a) por lo general, es recomendable tener una clase o un servicio singleton dedicado para controlar el Raycast de fijamente en la escena y, a continuación, volver a usar este resultado en todos los demás componentes de la escena, en lugar de realizar operaciones Raycast repetidas y esencialmente idénticas en cada pone.</span><span class="sxs-lookup"><span data-stu-id="086f6-172">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="086f6-173">Por supuesto, algunas aplicaciones pueden requerir raycasts de diferentes orígenes o de [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html)diferentes.</span><span class="sxs-lookup"><span data-stu-id="086f6-173">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="086f6-174">b) Evite las operaciones GetComponent () en las devoluciones de llamada de Unity repetidas como Update () mediante el [almacenamiento en caché de las referencias](#cache-references) en Start () o activo ()</span><span class="sxs-lookup"><span data-stu-id="086f6-174">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="086f6-175">c) es recomendable crear una instancia de todos los objetos, si es posible, en la inicialización y usar la [agrupación de objetos](#object-pooling) para reciclar y volver a usar GameObjects en tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-175">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="086f6-176">**Evitar interfaces y construcciones virtuales**</span><span class="sxs-lookup"><span data-stu-id="086f6-176">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="086f6-177">La invocación de llamadas a funciones a través de interfaces frente a objetos directos o llamadas a funciones virtuales a menudo puede ser mucho más costosa que usar construcciones directas o llamadas a funciones directas.</span><span class="sxs-lookup"><span data-stu-id="086f6-177">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="086f6-178">Si la función virtual o la interfaz no son necesarias, se debe quitar.</span><span class="sxs-lookup"><span data-stu-id="086f6-178">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="086f6-179">Sin embargo, el impacto en el rendimiento de estos enfoques por lo general merece la pena el equilibrio si su uso simplifica la colaboración en el desarrollo, la legibilidad del código y el mantenimiento del código.</span><span class="sxs-lookup"><span data-stu-id="086f6-179">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="086f6-180">Por lo general, la recomendación es no marcar los campos y las funciones como virtuales a menos que haya una expectativa clara de que sea necesario sobrescribir este miembro.</span><span class="sxs-lookup"><span data-stu-id="086f6-180">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="086f6-181">Debe ser especialmente cauto en torno a las rutas de acceso de código de alta frecuencia a las que se llama muchas veces por fotograma, o incluso una vez por fotograma, como un método `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="086f6-181">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="086f6-182">**Evite pasar Structs por valor**</span><span class="sxs-lookup"><span data-stu-id="086f6-182">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="086f6-183">A diferencia de las clases, las estructuras son tipos de valor y, cuando se pasan directamente a una función, su contenido se copia en una instancia recién creada.</span><span class="sxs-lookup"><span data-stu-id="086f6-183">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="086f6-184">Esta copia agrega costo de CPU, así como memoria adicional en la pila.</span><span class="sxs-lookup"><span data-stu-id="086f6-184">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="086f6-185">En el caso de las estructuras pequeñas, el efecto es normalmente muy mínimo y, por tanto, aceptable.</span><span class="sxs-lookup"><span data-stu-id="086f6-185">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="086f6-186">Sin embargo, para las funciones invocadas repetidamente cada fotograma y las funciones que toman estructuras grandes, si es posible, modifique la definición de función para que pase por referencia.</span><span class="sxs-lookup"><span data-stu-id="086f6-186">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="086f6-187">在這裡深入了解</span><span class="sxs-lookup"><span data-stu-id="086f6-187">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="086f6-188">其他</span><span class="sxs-lookup"><span data-stu-id="086f6-188">Miscellaneous</span></span>

1) <span data-ttu-id="086f6-189">**Efectos**</span><span class="sxs-lookup"><span data-stu-id="086f6-189">**Physics**</span></span>

    <span data-ttu-id="086f6-190">a) por lo general, la manera más fácil de mejorar la física es limitar la cantidad de tiempo empleado en la física o el número de iteraciones por segundo.</span><span class="sxs-lookup"><span data-stu-id="086f6-190">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="086f6-191">Por supuesto, esto reducirá la precisión de la simulación.</span><span class="sxs-lookup"><span data-stu-id="086f6-191">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="086f6-192">Consulte [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) en Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-192">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="086f6-193">b) el tipo de colisionadores en Unity tiene características de rendimiento muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="086f6-193">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="086f6-194">En el orden siguiente se enumeran los colisiones de mayor rendimiento de los colisionadores con menos rendimiento de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="086f6-194">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="086f6-195">Es más importante evitar los colisionadores de malla, que son mucho más caros que los colisionadores primitivos.</span><span class="sxs-lookup"><span data-stu-id="086f6-195">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="086f6-196">Consulte [prácticas recomendadas](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) de la física de Unity para obtener más información</span><span class="sxs-lookup"><span data-stu-id="086f6-196">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="086f6-197">**Animaciones**</span><span class="sxs-lookup"><span data-stu-id="086f6-197">**Animations**</span></span>

    <span data-ttu-id="086f6-198">Deshabilitar animaciones inactivas deshabilitando el componente de animación (la deshabilitación del objeto de juego no tendrá el mismo efecto).</span><span class="sxs-lookup"><span data-stu-id="086f6-198">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="086f6-199">Evite patrones de diseño en los que un animador se encuentre en un bucle estableciendo un valor en lo mismo.</span><span class="sxs-lookup"><span data-stu-id="086f6-199">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="086f6-200">Esta técnica conlleva una sobrecarga considerable, sin ningún efecto en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-200">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="086f6-201">Obtenga más información aquí.</span><span class="sxs-lookup"><span data-stu-id="086f6-201">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="086f6-202">**Algoritmos complejos**</span><span class="sxs-lookup"><span data-stu-id="086f6-202">**Complex algorithms**</span></span>

    <span data-ttu-id="086f6-203">Si su aplicación usa algoritmos complejos, como cinemáticas inversas, búsqueda de rutas de acceso, etc., busque un enfoque más sencillo o ajuste los valores de configuración relevantes para su rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-203">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="086f6-204">Recomendaciones de rendimiento de CPU a GPU</span><span class="sxs-lookup"><span data-stu-id="086f6-204">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="086f6-205">Por lo general, el rendimiento de la CPU a la GPU se reduce a las **llamadas de dibujo** enviadas a la tarjeta gráfica.</span><span class="sxs-lookup"><span data-stu-id="086f6-205">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="086f6-206">Para mejorar el rendimiento, las llamadas a Draw deben ser estratégicamente **a) reducidas** o **b) reestructuradas** para obtener resultados óptimos.</span><span class="sxs-lookup"><span data-stu-id="086f6-206">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="086f6-207">Dado que las llamadas de dibujo a sí mismas son de uso intensivo de recursos, reducirlos reducirá todo el trabajo necesario.</span><span class="sxs-lookup"><span data-stu-id="086f6-207">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="086f6-208">Además, los cambios de estado entre llamadas de dibujo requieren pasos de traducción y validación costosos en el controlador de gráficos y, por lo tanto, la reestructuración de las llamadas a Draw de la aplicación para limitar los cambios de estado (es decir,</span><span class="sxs-lookup"><span data-stu-id="086f6-208">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="086f6-209">distintos materiales, etc.) pueden mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-209">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="086f6-210">Unity tiene un excelente artículo que proporciona información general y profundiza en el procesamiento por lotes de las llamadas de dibujo para su plataforma.</span><span class="sxs-lookup"><span data-stu-id="086f6-210">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="086f6-211">Procesamiento por lotes de llamadas de Unity Draw</span><span class="sxs-lookup"><span data-stu-id="086f6-211">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="086f6-212">Representación con instancia de un solo paso</span><span class="sxs-lookup"><span data-stu-id="086f6-212">Single pass instanced rendering</span></span>

<span data-ttu-id="086f6-213">La representación con instancia de un solo paso en Unity permite que las llamadas de dibujo de cada ojo se reduzcan a una llamada a Draw con instancias.</span><span class="sxs-lookup"><span data-stu-id="086f6-213">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="086f6-214">Debido a la coherencia de la memoria caché entre dos llamadas a Draw, también hay una mejora del rendimiento en la GPU.</span><span class="sxs-lookup"><span data-stu-id="086f6-214">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="086f6-215">Para habilitar esta característica en el proyecto de Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-215">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="086f6-216">Abra la configuración de el **reproductor XR** (vaya a **Editar** > **configuración del proyecto** > **Player** > **configuración de XR**)</span><span class="sxs-lookup"><span data-stu-id="086f6-216">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="086f6-217">Seleccione **una instancia de paso único** en el menú desplegable **método de representación de estéreo** (se debe activar la casilla se admite la**realidad virtual** )</span><span class="sxs-lookup"><span data-stu-id="086f6-217">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="086f6-218">Lea los siguientes artículos de Unity para obtener más información sobre este enfoque de representación.</span><span class="sxs-lookup"><span data-stu-id="086f6-218">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="086f6-219">Cómo maximizar el rendimiento de AR y VR con la representación avanzada de estéreo</span><span class="sxs-lookup"><span data-stu-id="086f6-219">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="086f6-220">Creación de instancias de un solo paso</span><span class="sxs-lookup"><span data-stu-id="086f6-220">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="086f6-221">Un problema común con la representación con instancias de paso único se produce si los desarrolladores ya tienen sombreadores personalizados no escritos para la creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="086f6-221">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="086f6-222">Después de habilitar esta característica, los desarrolladores pueden observar que algunos GameObjects solo se representan en un ojo.</span><span class="sxs-lookup"><span data-stu-id="086f6-222">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="086f6-223">Esto se debe a que los sombreadores personalizados asociados no tienen las propiedades adecuadas para la creación de instancias.</span><span class="sxs-lookup"><span data-stu-id="086f6-223">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="086f6-224">Consulte [representación de un solo paso estéreo para HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) desde Unity para saber cómo solucionar este problema.</span><span class="sxs-lookup"><span data-stu-id="086f6-224">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="086f6-225">Procesamiento por lotes estático</span><span class="sxs-lookup"><span data-stu-id="086f6-225">Static batching</span></span>

<span data-ttu-id="086f6-226">Unity puede procesar por lotes muchos objetos estáticos para reducir las llamadas de dibujo a la GPU.</span><span class="sxs-lookup"><span data-stu-id="086f6-226">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="086f6-227">El procesamiento por lotes estático funciona para la mayoría de los objetos de [representador](https://docs.unity3d.com/ScriptReference/Renderer.html) en Unity que **1) comparten el mismo material** y **2) se marcan como *estáticos*** (Seleccione un objeto en Unity y haga clic en la casilla situada en la parte superior derecha del inspector).</span><span class="sxs-lookup"><span data-stu-id="086f6-227">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="086f6-228">Los GameObjects marcados como *static* no se pueden transferir a lo largo del tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-228">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="086f6-229">Por lo tanto, el procesamiento por lotes estático puede ser difícil de aprovechar en HoloLens, donde prácticamente todos los objetos deben colocarse, moverse, escalarse, etc. En el caso de los auriculares más envolventes, el procesamiento por lotes estático puede reducir drásticamente las llamadas a Draw y mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-229">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="086f6-230">Lea *procesamiento por lotes estático* en [procesamiento por lotes de llamadas en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="086f6-230">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="086f6-231">Procesamiento por lotes dinámico</span><span class="sxs-lookup"><span data-stu-id="086f6-231">Dynamic batching</span></span>

<span data-ttu-id="086f6-232">Dado que es problemático marcar objetos como *estáticos* para el desarrollo de HoloLens, el procesamiento por lotes dinámico puede ser una herramienta excelente para compensar esta característica que falta.</span><span class="sxs-lookup"><span data-stu-id="086f6-232">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="086f6-233">Por supuesto, también puede ser útil en los auriculares más envolventes.</span><span class="sxs-lookup"><span data-stu-id="086f6-233">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="086f6-234">Sin embargo, el procesamiento por lotes dinámico en Unity puede ser difícil de habilitar porque GameObjects debe tener **un recurso compartido con el mismo material** y **b) cumplir una larga lista de otros criterios**.</span><span class="sxs-lookup"><span data-stu-id="086f6-234">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="086f6-235">Lea *procesamiento por lotes dinámico* en el [procesamiento por lotes de llamadas en Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obtener la lista completa.</span><span class="sxs-lookup"><span data-stu-id="086f6-235">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="086f6-236">Normalmente, GameObjects dejan de ser válidos para procesarse por lotes dinámicamente, porque los datos de malla asociados no pueden ser más de 300 vértices.</span><span class="sxs-lookup"><span data-stu-id="086f6-236">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="086f6-237">Otras técnicas</span><span class="sxs-lookup"><span data-stu-id="086f6-237">Other techniques</span></span>

<span data-ttu-id="086f6-238">El procesamiento por lotes solo puede producirse si varios GameObjects pueden compartir el mismo material.</span><span class="sxs-lookup"><span data-stu-id="086f6-238">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="086f6-239">Normalmente, se bloqueará la necesidad de que GameObjects tenga una textura única para su material respectivo.</span><span class="sxs-lookup"><span data-stu-id="086f6-239">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="086f6-240">Es habitual combinar texturas en una sola textura grande, un método conocido como [Atlas de textura](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="086f6-240">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="086f6-241">Además, suele ser preferible combinar las mallas en una GameObject siempre que sea posible y razonable.</span><span class="sxs-lookup"><span data-stu-id="086f6-241">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="086f6-242">Cada representador en Unity tendrá sus llamadas a Draw asociadas y enviará una malla combinada bajo un representador.</span><span class="sxs-lookup"><span data-stu-id="086f6-242">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="086f6-243">La modificación de las propiedades del representador. el material en tiempo de ejecución creará una copia del material y, por tanto, puede romper el procesamiento por lotes.</span><span class="sxs-lookup"><span data-stu-id="086f6-243">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="086f6-244">Use renderer. sharedMaterial para modificar las propiedades de material compartido en GameObjects.</span><span class="sxs-lookup"><span data-stu-id="086f6-244">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="086f6-245">Recomendaciones de rendimiento de GPU</span><span class="sxs-lookup"><span data-stu-id="086f6-245">GPU performance recommendations</span></span>

<span data-ttu-id="086f6-246">Más información sobre la [optimización de la representación de gráficos en Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="086f6-246">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="086f6-247">Optimizar el uso compartido de búfer de profundidad</span><span class="sxs-lookup"><span data-stu-id="086f6-247">Optimize depth buffer sharing</span></span>

<span data-ttu-id="086f6-248">Por lo general, se recomienda habilitar el **uso compartido de búfer de profundidad** en **Player XR Settings** para optimizar la estabilidad de los [hologramas](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="086f6-248">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="086f6-249">Sin embargo, al habilitar la Reproyección en fases posteriores basada en la profundidad con esta configuración, se recomienda seleccionar el **formato de profundidad de 16 bits** en lugar del **formato de profundidad de 24 bits**.</span><span class="sxs-lookup"><span data-stu-id="086f6-249">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="086f6-250">Los búferes de profundidad de 16 bits reducirán drásticamente el ancho de banda (y, por lo tanto, la potencia) asociado con el tráfico de búfer de profundidad.</span><span class="sxs-lookup"><span data-stu-id="086f6-250">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="086f6-251">Esto puede ser una gran victoria tanto en la reducción de energía como en la mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="086f6-251">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="086f6-252">Sin embargo, hay dos posibles resultados negativos con *el formato de profundidad de 16 bits*.</span><span class="sxs-lookup"><span data-stu-id="086f6-252">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="086f6-253">**Lucha Z**</span><span class="sxs-lookup"><span data-stu-id="086f6-253">**Z-Fighting**</span></span>

<span data-ttu-id="086f6-254">La fidelidad de rango de profundidad reducida hace que las supuestos de [z](https://en.wikipedia.org/wiki/Z-fighting) sean más probables que se produzcan con 16 bits de 24 bits.</span><span class="sxs-lookup"><span data-stu-id="086f6-254">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="086f6-255">Para evitar estos artefactos, modifique los planos de clips cercanos o lejos de la [cámara de Unity](https://docs.unity3d.com/Manual/class-Camera.html) para tener en cuenta la precisión más baja.</span><span class="sxs-lookup"><span data-stu-id="086f6-255">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="086f6-256">En el caso de las aplicaciones basadas en HoloLens, un plano de recorte lejano de 50 millones, en lugar del valor predeterminado de Unity, puede eliminar cualquier combate z.</span><span class="sxs-lookup"><span data-stu-id="086f6-256">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="086f6-257">**Búfer de estarcido deshabilitado**</span><span class="sxs-lookup"><span data-stu-id="086f6-257">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="086f6-258">Cuando Unity crea una [textura de representación con una profundidad de 16 bits](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), no se crea ningún búfer de estarcido.</span><span class="sxs-lookup"><span data-stu-id="086f6-258">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="086f6-259">Al seleccionar el formato de profundidad de 24 bits, por documentación de Unity, se creará un búfer z de 24 bits, así como un [búfer de estarcido de 8 bits] (https://docs.unity3d.com/Manual/SL-Stencil.html) (si 32 bits es aplicable en un dispositivo, que suele ser el caso como HoloLens).</span><span class="sxs-lookup"><span data-stu-id="086f6-259">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="086f6-260">Evitar efectos de pantalla completa</span><span class="sxs-lookup"><span data-stu-id="086f6-260">Avoid full-screen effects</span></span>

<span data-ttu-id="086f6-261">Las técnicas que operan en la pantalla completa pueden resultar bastante costosas, ya que su orden de magnitud es millones de operaciones en cada fotograma.</span><span class="sxs-lookup"><span data-stu-id="086f6-261">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="086f6-262">Por lo tanto, se recomienda evitar los [efectos posteriores al procesamiento](https://docs.unity3d.com/Manual/PostProcessingOverview.html) , como el suavizado de contorno, la floración, etc.</span><span class="sxs-lookup"><span data-stu-id="086f6-262">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="086f6-263">Configuración de iluminación óptima</span><span class="sxs-lookup"><span data-stu-id="086f6-263">Optimal lighting settings</span></span>

<span data-ttu-id="086f6-264">[La iluminación global en tiempo real](https://docs.unity3d.com/Manual/GIIntro.html) en Unity puede proporcionar resultados visuales pendientes, pero implica cálculos de iluminación bastante costosos.</span><span class="sxs-lookup"><span data-stu-id="086f6-264">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="086f6-265">Se recomienda deshabilitar la iluminación global en tiempo real para cada archivo de escena de Unity a través de **Window** > la **representación** de > **configuración de iluminación** > desactivar **la iluminación global en tiempo real**.</span><span class="sxs-lookup"><span data-stu-id="086f6-265">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="086f6-266">Además, se recomienda deshabilitar todas las conversiones de instantáneas, ya que también se pueden agregar pasadas de GPU costosas a una escena de Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-266">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="086f6-267">Las sombras se pueden deshabilitar por luz, pero también se pueden controlar holísticamente a través de la configuración de calidad.</span><span class="sxs-lookup"><span data-stu-id="086f6-267">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="086f6-268">**Edite** > **configuración del proyecto**y, a continuación, seleccione la categoría **calidad** > seleccione **calidad baja** para la plataforma UWP.</span><span class="sxs-lookup"><span data-stu-id="086f6-268">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="086f6-269">También puede establecer la propiedad **Shadows** para **deshabilitar Shadows**.</span><span class="sxs-lookup"><span data-stu-id="086f6-269">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="086f6-270">Reducir el número de poli</span><span class="sxs-lookup"><span data-stu-id="086f6-270">Reduce poly count</span></span>

<span data-ttu-id="086f6-271">Normalmente, se reduce el número de polígonos.</span><span class="sxs-lookup"><span data-stu-id="086f6-271">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="086f6-272">Quitar objetos de una escena</span><span class="sxs-lookup"><span data-stu-id="086f6-272">Removing objects from a scene</span></span>
2) <span data-ttu-id="086f6-273">La diezmación de recursos, lo que reduce el número de polígonos de una malla determinada</span><span class="sxs-lookup"><span data-stu-id="086f6-273">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="086f6-274">Implementar un [sistema de nivel de detalle (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) en la aplicación que representa objetos alejados con una versión de polígono inferior de la misma geometría</span><span class="sxs-lookup"><span data-stu-id="086f6-274">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="086f6-275">Descripción de los sombreadores en Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-275">Understanding shaders in Unity</span></span>

<span data-ttu-id="086f6-276">Una aproximación sencilla para comparar los sombreadores en el rendimiento es identificar el promedio de operaciones que cada una se ejecuta en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="086f6-276">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="086f6-277">Esto se puede hacer fácilmente en Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-277">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="086f6-278">Seleccione el recurso de sombreador o seleccione un material y, a continuación, en la esquina superior derecha de la ventana del inspector, seleccione el icono de engranaje seguido de **"seleccionar sombreador"** .</span><span class="sxs-lookup"><span data-stu-id="086f6-278">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Selección del sombreador en Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="086f6-280">Con el recurso de sombreador seleccionado, haga clic en el botón **"compilar y Mostrar código"** en la ventana del inspector.</span><span class="sxs-lookup"><span data-stu-id="086f6-280">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilar código de sombreador en Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="086f6-282">Después de compilar, busque la sección de estadísticas en los resultados con el número de operaciones diferentes para el sombreador de vértices y píxeles (Nota: los sombreadores de píxeles se suelen denominar sombreadores de fragmentos)</span><span class="sxs-lookup"><span data-stu-id="086f6-282">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operaciones del sombreador estándar de Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="086f6-284">Optimizar los sombreadores de píxeles</span><span class="sxs-lookup"><span data-stu-id="086f6-284">Optimize pixel shaders</span></span>

<span data-ttu-id="086f6-285">Si se examinan los resultados de la estadística compilada con el método anterior, el [sombreador de fragmentos](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) normalmente ejecutará más operaciones que el [sombreador de vértices](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), en promedio.</span><span class="sxs-lookup"><span data-stu-id="086f6-285">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="086f6-286">El sombreador de fragmentos, también conocido como sombreador de píxeles, se ejecuta por píxel en la salida de la pantalla, mientras que el sombreador de vértices solo se ejecuta por vértice de todas las mallas que se dibujan en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="086f6-286">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="086f6-287">Por lo tanto, no solo los sombreadores de fragmentos tienen más instrucciones que los sombreadores de vértices debido a todos los cálculos de iluminación, los sombreadores de fragmentos casi siempre se ejecutan en un conjunto de DataSet más grande.</span><span class="sxs-lookup"><span data-stu-id="086f6-287">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="086f6-288">Por ejemplo, si la salida de pantalla es una imagen de 2K por 2K, el sombreador de fragmentos puede ejecutarse 2000 \* 2000 = 4 millones veces.</span><span class="sxs-lookup"><span data-stu-id="086f6-288">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="086f6-289">Si se representan dos ojos, este número se duplica ya que hay dos pantallas.</span><span class="sxs-lookup"><span data-stu-id="086f6-289">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="086f6-290">Si una aplicación de realidad mixta tiene varios pasos, efectos de procesamiento posterior de pantalla completa o representación de varias mallas en el mismo píxel, este número aumentará drásticamente.</span><span class="sxs-lookup"><span data-stu-id="086f6-290">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="086f6-291">Por lo tanto, reducir el número de operaciones en el sombreador de fragmentos normalmente puede proporcionar mejoras de rendimiento mucho mayores en las optimizaciones del sombreador de vértices.</span><span class="sxs-lookup"><span data-stu-id="086f6-291">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="086f6-292">Alternativas del sombreador estándar de Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-292">Unity Standard shader alternatives</span></span>

<span data-ttu-id="086f6-293">En lugar de usar una representación basada físicamente (PBR) u otro sombreador de alta calidad, consulte uso de un sombreador más eficaz y más económico.</span><span class="sxs-lookup"><span data-stu-id="086f6-293">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="086f6-294">El [Kit de herramientas de realidad mixta](https://github.com/Microsoft/MixedRealityToolkit-Unity) proporciona el [sombreador estándar de MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) que se ha optimizado para proyectos de realidad mixta.</span><span class="sxs-lookup"><span data-stu-id="086f6-294">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="086f6-295">Unity también proporciona un sin iluminación, un vértice iluminado, difuso y otras opciones de sombreador simplificado que son mucho más rápidas en comparación con el sombreador estándar de Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-295">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="086f6-296">Vea [uso y rendimiento de los sombreadores integrados](https://docs.unity3d.com/Manual/shader-Performance.html) para obtener información más detallada.</span><span class="sxs-lookup"><span data-stu-id="086f6-296">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="086f6-297">Carga previa del sombreador</span><span class="sxs-lookup"><span data-stu-id="086f6-297">Shader preloading</span></span>

<span data-ttu-id="086f6-298">Use la *carga previa del sombreador* y otros trucos para optimizar [el tiempo de carga del sombreador](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="086f6-298">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="086f6-299">En concreto, la precarga del sombreador significa que no verá ningún desequilibrio debido a la compilación del sombreador en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="086f6-299">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="086f6-300">Sobredibujar límite</span><span class="sxs-lookup"><span data-stu-id="086f6-300">Limit overdraw</span></span>

<span data-ttu-id="086f6-301">En Unity, se puede mostrar el sobredibujo de la escena, alternando el [**menú modo de dibujo**](https://docs.unity3d.com/Manual/ViewModes.html) en la esquina superior izquierda de la **vista de escena** y seleccionando **desdibujando**.</span><span class="sxs-lookup"><span data-stu-id="086f6-301">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="086f6-302">Por lo general, el sobredibujo se puede mitigar Reseleccionando los objetos antes de enviarlos a la GPU.</span><span class="sxs-lookup"><span data-stu-id="086f6-302">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="086f6-303">Unity proporciona detalles sobre la implementación de la selección de la [oclusión](https://docs.unity3d.com/Manual/OcclusionCulling.html) para su motor.</span><span class="sxs-lookup"><span data-stu-id="086f6-303">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="086f6-304">Recomendaciones de memoria</span><span class="sxs-lookup"><span data-stu-id="086f6-304">Memory recommendations</span></span>

<span data-ttu-id="086f6-305">Una asignación de memoria excesiva & las operaciones de desasignación pueden tener efectos negativos en la aplicación holográfica, lo que produce un rendimiento incoherente, fotogramas inmovilizados y otro comportamiento perjudicial.</span><span class="sxs-lookup"><span data-stu-id="086f6-305">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="086f6-306">Es especialmente importante comprender las consideraciones de memoria al desarrollar en Unity, ya que la administración de la memoria se controla mediante el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="086f6-306">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="086f6-307">記憶體回收</span><span class="sxs-lookup"><span data-stu-id="086f6-307">Garbage collection</span></span>

<span data-ttu-id="086f6-308">Las aplicaciones holográficas perderán el procesamiento del tiempo de proceso en el recolector de elementos no utilizados (GC) cuando se active el GC para analizar los objetos que ya no están en el ámbito durante la ejecución y se debe liberar su memoria, por lo que puede estar disponible para su reutilización.</span><span class="sxs-lookup"><span data-stu-id="086f6-308">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="086f6-309">Normalmente, las asignaciones y desasignaciones constantes requerirán que el recolector de elementos no utilizados se ejecute con más frecuencia, con lo que se perjudica el rendimiento y la experiencia del usuario.</span><span class="sxs-lookup"><span data-stu-id="086f6-309">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="086f6-310">Unity ha proporcionado una página excelente que explica en detalle cómo funciona el recolector de elementos no utilizados y sugerencias para escribir código más eficaz en lo que respecta a la administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="086f6-310">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="086f6-311">Optimizar la recolección de elementos no utilizados en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-311">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="086f6-312">Una de las prácticas más comunes que conduce a una recolección de elementos no utilizados excesiva no almacena en caché las referencias a componentes y clases en el desarrollo de Unity.</span><span class="sxs-lookup"><span data-stu-id="086f6-312">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="086f6-313">Las referencias deben capturarse durante el inicio () o activo () y se pueden volver a usar en funciones posteriores como Update () o LateUpdate ().</span><span class="sxs-lookup"><span data-stu-id="086f6-313">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="086f6-314">Otras sugerencias rápidas:</span><span class="sxs-lookup"><span data-stu-id="086f6-314">Other quick tips:</span></span>
- <span data-ttu-id="086f6-315">Usar la clase [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# para compilar dinámicamente cadenas complejas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="086f6-315">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="086f6-316">Quite las llamadas a Debug. log () cuando ya no sean necesarias, ya que se ejecutan en todas las versiones de compilación de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-316">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="086f6-317">Si la aplicación holográfica normalmente requiere una gran cantidad de memoria, considere la posibilidad de llamar a [ _**System. GC. Collect ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante las fases de carga, como cuando se presenta una pantalla de carga o transición.</span><span class="sxs-lookup"><span data-stu-id="086f6-317">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="086f6-318">Agrupación de objetos</span><span class="sxs-lookup"><span data-stu-id="086f6-318">Object pooling</span></span>

<span data-ttu-id="086f6-319">La agrupación de objetos es una técnica popular para reducir el costo de las asignaciones continuas & desasignaciones de objetos.</span><span class="sxs-lookup"><span data-stu-id="086f6-319">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="086f6-320">Para ello, se asigna un grupo grande de objetos idénticos y se reutilizan instancias disponibles inactivas de este grupo en lugar de generar y destruir objetos constantemente a lo largo del tiempo.</span><span class="sxs-lookup"><span data-stu-id="086f6-320">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="086f6-321">Los grupos de objetos son excelentes para los componentes reutilizables que tienen una duración variable durante una aplicación.</span><span class="sxs-lookup"><span data-stu-id="086f6-321">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="086f6-322">Tutorial de agrupación de objetos en Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-322">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="086f6-323">啟動效能</span><span class="sxs-lookup"><span data-stu-id="086f6-323">Startup performance</span></span>

<span data-ttu-id="086f6-324">Considere la posibilidad de iniciar la aplicación con una escena más pequeña y luego use *[SceneManager. LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* para cargar el resto de la escena.</span><span class="sxs-lookup"><span data-stu-id="086f6-324">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="086f6-325">Esto permite a la aplicación acceder a un estado interactivo lo más rápido posible.</span><span class="sxs-lookup"><span data-stu-id="086f6-325">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="086f6-326">Tenga en cuenta que puede haber un gran aumento de la CPU mientras se activa la nueva escena y que cualquier contenido representado puede producir un error o una dificultad.</span><span class="sxs-lookup"><span data-stu-id="086f6-326">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="086f6-327">Una manera de solucionar este aspecto es establecer la propiedad AsyncOperation. allowSceneActivation en "false" en la escena que se está cargando, esperar a que se cargue la escena, borrar la pantalla a negro y volver a establecerla en "true" para completar la activación de la escena.</span><span class="sxs-lookup"><span data-stu-id="086f6-327">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="086f6-328">Recuerde que mientras se carga la escena de inicio, se mostrará la pantalla de presentación holográfica al usuario.</span><span class="sxs-lookup"><span data-stu-id="086f6-328">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="086f6-329">請參閱</span><span class="sxs-lookup"><span data-stu-id="086f6-329">See also</span></span>
- [<span data-ttu-id="086f6-330">Optimización de la representación de gráficos en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-330">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="086f6-331">Optimizar la recolección de elementos no utilizados en juegos de Unity</span><span class="sxs-lookup"><span data-stu-id="086f6-331">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="086f6-332">[Prácticas recomendadas de la física [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="086f6-332">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="086f6-333">[Optimizar scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="086f6-333">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
